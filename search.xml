<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>【Git】Github 够用指南</title>
    <url>/2021/07/14/%E3%80%90Git%E3%80%91Github%E5%A4%9F%E7%94%A8%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<blockquote>
<p>这篇文章介绍了 Git 和 Github 的够用操作。</p>
</blockquote>
<span id="more"></span>
<h2 id="git-和-github-分别是什么">Git 和 Github 分别是什么</h2>
<ul>
<li>Git 是一个运行在你电脑上的<strong>版本控制软件</strong>，而 Github 是基于 Git 这个版本控制软件打造的网站</li>
<li>Git 的三个概念
<ul>
<li>仓库 repository：项目的源文件夹是一个本地仓库，也可以将项目提交到云仓库 Github、码云等</li>
<li>分支 branch：多人同时在开发同一个项目，可以开辟不同的分支，各写各的，最后完成合并</li>
<li>提交 commit：可以把一个人乃至多个人代码的变更以提交的形式做一个存储，当代码写崩的时候可以找回历史记录</li>
</ul></li>
</ul>
<h2 id="安装git">安装（Git）</h2>
<ul>
<li><a href="https://gitforwindows.org/">git</a></li>
<li><a href="https://code.visualstudio.com/">vscode</a></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git --version</span><br></pre></td></tr></table></figure>
<h2 id="看别人的项目github">看别人的项目（Github）</h2>
<blockquote>
<p>git clone, Star, README.md, issue, LICENSE</p>
</blockquote>
<ul>
<li>下载项目
<ul>
<li><code>git clone</code> 下载下来的是一个仓库</li>
<li>而直接官网 <code>download</code> 下的是一个文件夹，少了 <code>.git</code> 隐藏文件</li>
</ul></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> address</span><br></pre></td></tr></table></figure>
<h2 id="找好的开源项目github">找好的开源项目（Github）</h2>
<ul>
<li><a href="https://github.com/trending/">热门项目</a></li>
<li><a href="https://github.com/521xueweihan/HelloGitHub">按照不同语言定期的项目</a></li>
<li><a href="https://github.com/ruanyf/weekly">科技新闻+有意思的工具</a></li>
<li><a href="https://www.zhihu.com/column/mm-fe">前端的工具</a></li>
</ul>
<h2 id="查找资源的技巧github">查找资源的技巧（Github）</h2>
<ul>
<li>找百科大全： <strong>awesome</strong> xxx</li>
<li>找例子： xxx <strong>sample</strong></li>
<li>找空项目架子-<strong>模板</strong>： xxx <strong>starter</strong> / xxx boilerplate</li>
<li>找教程： xxx <strong>tutorial</strong></li>
</ul>
<h2 id="够用的-git-命令">够用的 Git 命令</h2>
<ul>
<li>将<strong>普通文件夹</strong>变为 <strong>git 仓库</strong>
<ul>
<li>之前是有个信息确认的。
<ul>
<li><code>git config --global user.name &quot;PzLu&quot;</code></li>
<li><code>git config --global user.email &quot;my_email@outlook.com&quot;</code></li>
</ul></li>
</ul></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git init</span><br></pre></td></tr></table></figure>
<ul>
<li>第一次提交（本地）</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git add -A <span class="comment"># 添加所有文件到暂存区</span></span><br><span class="line">$ git commit -m <span class="string">&quot;提交信息&quot;</span> <span class="comment"># 把暂存区的文件提交到仓库</span></span><br></pre></td></tr></table></figure>
<p><img src="https://user-images.githubusercontent.com/48743005/125591162-69901c03-eae2-4e08-9853-28478c8540af.png" /></p>
<ul>
<li>查看提交的历史记录（本地）</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --<span class="built_in">stat</span> <span class="comment"># q退出</span></span><br></pre></td></tr></table></figure>
<ul>
<li>维护项目的日常（本地）</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git checkout filename <span class="comment">#工作区回滚，此时未提交</span></span><br><span class="line">$ git reset HEAD^1 <span class="comment">#撤销最后一次提交</span></span><br></pre></td></tr></table></figure>
<ul>
<li>分支（本地）
<ul>
<li>以当前分支为基础<strong>新建分支</strong>：<code>git checkout -b branchname</code></li>
<li><strong>列举所有</strong>的分支：<code>git branch</code></li>
<li>单纯地<strong>切换</strong>到某个分支：<code>git checkout branchname</code></li>
<li><strong>删掉</strong>特定的分支：<code>git branch -D branchname</code></li>
<li>回到主分支后，<strong>合并其他</strong>分支：<code>git merge branchname</code></li>
</ul></li>
<li>Git 和 GitHub 远程仓库（远程）
<ul>
<li><strong>推送</strong>当前分支最新的提交到远程：<code>git push</code>
<ul>
<li>本地写好代码，变成仓库，并有一些提交</li>
<li>在 Github 上开一个新的仓库</li>
<li>按照 Github 上面的要求，在本地终端推送
<ul>
<li>（第一次）关联一个远程库：<code>git remote add origin git@server-name:path/repo-name.git</code>，<code>origin</code>是默认习惯命名（<strong>注意是git@</strong>）</li>
<li>（第一次）改名字（master-&gt;main）：<code>git branch -M main</code></li>
<li>（第一次）推送master分支的所有内容：<code>git push -u origin main</code></li>
<li>（接着）每次提交，直接：<code>git push origin main</code>，不用加 <code>-u</code></li>
</ul></li>
</ul></li>
<li><strong>拉取</strong>远程分支最新的提交到本地：<code>git pull</code></li>
</ul></li>
</ul>
<h2 id="fork-github项目-clone-push">fork-github项目-clone-push</h2>
<blockquote>
<p>需求：</p>
<ul>
<li>想将一个牛逼的项目复制到自己的 github 仓库</li>
<li>想将仓库中的代码拉取到本地进行修改</li>
<li>想将修改后的代码推送到自己的 github 仓库</li>
<li>想将复制过来并修改后的代码再还给原作者，请求人家让你合并。</li>
</ul>
</blockquote>
<h3 id="复制到自己的-github-仓库里">复制到自己的 github 仓库里</h3>
<ul>
<li>fork 即可</li>
</ul>
<p><img src="https://user-images.githubusercontent.com/48743005/131211305-089d5111-c07e-4d79-a196-346ee2f7c8ab.png" /> <img src="https://user-images.githubusercontent.com/48743005/131211314-4416a5eb-545b-43a5-8fac-7583f4594597.png" /></p>
<h3 id="将仓库中的代码拉取到本地进行修改">将仓库中的代码拉取到本地进行修改</h3>
<ul>
<li>终端命令，如</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> git@github.com:PzLu/doccano.git</span><br></pre></td></tr></table></figure>
<h3 id="想将修改后的代码推送到自己的-github-仓库">想将修改后的代码推送到自己的 github 仓库</h3>
<ul>
<li>接下来就可以对这个项目进行修改了.</li>
<li>但是不建议在 master 分支上直接修改，最好是在 master 分支基础上切出一个 v1 分支
<ul>
<li>然后在 v1 分支上修改，修改完成后，再将 v1 分支 merge 到 master 分支。</li>
</ul></li>
</ul>
<h4 id="切出-v1-分支">切出 v1 分支</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git checkout -b v1</span><br></pre></td></tr></table></figure>
<p><img src="https://user-images.githubusercontent.com/48743005/131211464-c92b3c6f-1317-4236-8898-f7c038d16f66.png" /></p>
<h4 id="进行修改">进行修改</h4>
<ul>
<li>可以在 v1 分支上测试下，随便加个文件，利用 vscode 的 commit 和提交
<ul>
<li>如 for_git_test</li>
</ul></li>
</ul>
<p><img src="https://user-images.githubusercontent.com/48743005/131211569-a1cdbb93-e83d-416f-abfd-e1a712d72610.png" /></p>
<h4 id="merge-一下并提交到自己的仓库">merge 一下，并提交到自己的仓库</h4>
<ul>
<li>转到 master 并 merge</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">$ git merge v1</span><br></pre></td></tr></table></figure>
<p><img src="https://user-images.githubusercontent.com/48743005/131211675-98148d59-919e-4b72-8905-84b47a9d76e4.png" /></p>
<ul>
<li>在自己的电脑上修改好代码后，再使用git push 命令将改动同步到自己的Github仓库中</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git push</span><br></pre></td></tr></table></figure>
<p><img src="https://user-images.githubusercontent.com/48743005/131211724-8a6744a9-dedb-4bb1-a3be-29c0d7523ec9.png" /></p>
<h3 id="想将复制过来并修改后的代码再还给原作者请求人家合并">想将复制过来并修改后的代码再还给原作者，请求人家合并</h3>
<ul>
<li>点击自己的仓库中的 pull request 下的 New pull request，之后 github 会自动对比</li>
<li>原仓库分支与自己仓库分支代码，看看是否有冲突。</li>
<li>如果它显示 Able to merge 的话，就可以点击 Create pull request 按钮，进行提交。</li>
<li>点击之后，会跳到注释的部分，可以跟原作者说明改动了什么，以及改的原因等。</li>
<li>最后点击绿色的 Create pull request 即可。</li>
<li>然后原作者就会收到pull request了。你也完成了对项目的贡献。</li>
</ul>
<h2 id="一些可能出现的问题">一些可能出现的问题</h2>
<h3 id="git-push-时本地仓库不能推送到远程仓库">git push 时本地仓库不能推送到远程仓库</h3>
<ul>
<li>问题原因：本地仓库和远程仓库的内容不一致，导致不能推送时</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 方法一：使用 git pull --rebase 命令</span></span><br><span class="line"><span class="comment">## 将远程仓库的master分支拉取到本地，然后合并到本地的master分支上</span></span><br><span class="line">$ git pull --rebase  origin master</span><br><span class="line"><span class="comment">## 此时再将本地仓库push到远端仓库中即可:</span></span><br><span class="line">$ git push -u origin master</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法二：允许合并</span></span><br><span class="line"><span class="comment">## 将远端仓库的master分支拉取、合并到本地的master分支</span></span><br><span class="line">$ git pull origin master --allow-unrelated-histories</span><br><span class="line"><span class="comment">## 然后再将本地仓库git push到远端</span></span><br><span class="line">$ git push -u origin master</span><br></pre></td></tr></table></figure>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://www.bilibili.com/video/BV1e541137Tc">Github 新手够用指南</a></li>
<li><a href="https://www.liaoxuefeng.com/wiki/896043488029600/896954117292416">远程仓库</a></li>
<li><a href="https://blog.csdn.net/Jeffxu_lib/article/details/88360540">git push 时本地仓库不能推送到远程仓库</a></li>
<li><a href="https://blog.csdn.net/qq_42348937/article/details/84640224">Git 本地重新设置</a></li>
<li><a href="https://www.jianshu.com/p/25a7ee982ad0">Mac 配置Git环境与常用指令</a></li>
<li><a href="https://blog.csdn.net/XiaoHanZuoFengZhou/article/details/86518180">GitHub怎样fork别人代码到自己仓库并进行贡献</a></li>
<li><a href="https://www.jianshu.com/p/9f95e4122957">如何把别人的项目修改后，提交到自己的 github</a></li>
</ul>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title>【Go】GoLang基础语法总结</title>
    <url>/2021/08/04/%E3%80%90Go%E3%80%91GoLang%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<blockquote>
<p>Go 是一个开源的编程语言，它能让构造简单、可靠且高效的软件变得容易。</p>
</blockquote>
<span id="more"></span>
<h1 id="环境配置windows篇章">环境配置（windows篇章）</h1>
<h2 id="下载---安装到指定盘比如d">下载 - 安装到指定盘（比如：D:）</h2>
<ul>
<li><a href="https://golang.org/dl/">下载地址</a></li>
</ul>
<p><img src="https://user-images.githubusercontent.com/48743005/128171750-f6f28e9f-e220-43da-8879-86f1ef180e6b.png" /></p>
<h2 id="依次配置gorootgopath工作路径path">依次配置GOROOT、GOPATH（工作路径）、Path</h2>
<p><img src="https://user-images.githubusercontent.com/48743005/128171823-e67112a6-d378-4a0c-aa76-a91717339d14.png" /> <img src="https://user-images.githubusercontent.com/48743005/128171850-c2b78d3d-e57a-4ec0-8280-7031f6daf26a.png" /> <img src="https://user-images.githubusercontent.com/48743005/128171866-7ef37134-0d13-4815-88d2-1039e09afa1f.png" /></p>
<h2 id="查看版本">查看版本</h2>
<ul>
<li><code>go version</code></li>
</ul>
<h2 id="配置-vscode---安装go插件">配置 Vscode - 安装Go插件</h2>
<p><img src="https://user-images.githubusercontent.com/48743005/128172435-32c7f269-30dd-46eb-9de6-7b389f3e2193.png" /></p>
<ul>
<li>选择设置选项</li>
</ul>
<p><img src="https://user-images.githubusercontent.com/48743005/128172557-06b5ba63-b517-49c6-9438-b7d9842eab06.png" /></p>
<ul>
<li>选择扩展Go configuration选择配置，在settings.json中编辑。</li>
</ul>
<p><img src="https://user-images.githubusercontent.com/48743005/128172613-f0a2a46d-d3c0-4888-8213-4743c2e67da1.png" /></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;go.buildOnSave&quot;</span>:<span class="string">&quot;off&quot;</span>,<span class="comment">// 保存代码时优化</span></span><br><span class="line"><span class="string">&quot;go.lintOnSave&quot;</span>:<span class="string">&quot;package&quot;</span>,<span class="comment">// 保存代码时检查潜在错误</span></span><br><span class="line"><span class="string">&quot;go.vetOnSave&quot;</span>:<span class="string">&quot;package&quot;</span>,<span class="comment">// 保存代码时执行测试</span></span><br><span class="line"><span class="string">&quot;go.coverOnSave&quot;</span>:<span class="literal">false</span>,</span><br><span class="line"><span class="string">&quot;go.useCodeSnippetsOnFunctionSuggest&quot;</span>:<span class="literal">true</span>,</span><br><span class="line"><span class="string">&quot;go.useCodeSnippetsOnFunctionSuggestWithoutType&quot;</span>:<span class="literal">true</span>,<span class="comment">// 代码格式化</span></span><br><span class="line"><span class="string">&quot;go.formatTool&quot;</span>:<span class="string">&quot;goreturns&quot;</span>,</span><br><span class="line"><span class="string">&quot;go.gocodePackageLookupMode&quot;</span>:<span class="string">&quot;go&quot;</span>,</span><br><span class="line"><span class="string">&quot;go.gotoSymbol.includeImports&quot;</span>:<span class="literal">true</span>,</span><br><span class="line"><span class="string">&quot;go.docsTool&quot;</span>:<span class="string">&quot;godoc&quot;</span>,</span><br><span class="line"><span class="string">&quot;go.inferGopath&quot;</span>:<span class="literal">true</span>,</span><br><span class="line"><span class="string">&quot;go.useLanguageServer&quot;</span>:<span class="literal">true</span>,</span><br><span class="line"><span class="string">&quot;go.autocompleteUnimportedPackages&quot;</span>:<span class="literal">true</span>,<span class="comment">// go语言安装环境目录</span></span><br><span class="line"><span class="string">&quot;go.goroot&quot;</span>:<span class="string">&quot;D:\\Golang&quot;</span>,<span class="comment">// go语言工作目录</span></span><br><span class="line"><span class="string">&quot;go.gopath&quot;</span>:<span class="string">&quot;C:\\Users\\panzhong171\\Desktop\\goProject&quot;</span>,</span><br><span class="line"><span class="string">&quot;go.gocodeAutoBuild&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"><span class="string">&quot;go.enableCodeLens&quot;</span>: &#123;</span><br><span class="line"></span><br><span class="line">    <span class="attr">&quot;references&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">&quot;runtest&quot;</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="确保安装好-git-的前提下完成配置">确保安装好 git 的前提下，完成配置。</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go env -w GO111MODULE=on </span><br><span class="line">$ go env -w GOPROXY=https://goproxy.cn,direct</span><br></pre></td></tr></table></figure>
<ul>
<li>然后打开vscode，看他报错点安装，就可以了。不需要手动安装包。</li>
</ul>
<h2 id="测试一下">测试一下</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   fmt.Println(<span class="string">&quot;Hello, World!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go run test.go</span><br><span class="line">Hello, World!</span><br></pre></td></tr></table></figure>
<h1 id="语言学习框架">语言学习框架</h1>
<h2 id="语言简介">语言简介</h2>
<h3 id="简介">简介</h3>
<ul>
<li>Go 是一个开源的编程语言，它能让构造简单、可靠且高效的软件变得容易。</li>
<li>Go是从2007年末由Robert Griesemer, Rob Pike, Ken Thompson主持开发，后来还加入了Ian Lance Taylor, Russ Cox等人，并最终于2009年11月开源，在2012年早些时候发布了Go 1稳定版本。现在Go的开发已经是完全开放的，并且拥有一个活跃的社区。</li>
</ul>
<h3 id="最主要的特性">最主要的特性</h3>
<ul>
<li>自动垃圾回收</li>
<li>更丰富的内置类型</li>
<li>函数多返回值</li>
<li>错误处理</li>
<li>匿名函数和闭包</li>
<li>类型和接口</li>
<li>并发编程</li>
<li>反射</li>
<li>语言交互性</li>
</ul>
<h3 id="主要用途">主要用途</h3>
<ul>
<li>Go 语言被设计成一门应用于搭载 Web 服务器，存储集群或类似用途的巨型中央服务器的系统编程语言。</li>
<li>对于高性能分布式系统领域而言，Go 语言无疑比大多数其它语言有着更高的开发效率。它提供了海量并行的支持，这对于游戏服务端的开发而言是再好不过了。</li>
</ul>
<h2 id="语言结构">语言结构</h2>
<blockquote>
<p>包声明-引入包-函数-变量-语句 &amp; 表达式-注释</p>
</blockquote>
<h3 id="一个例子">一个例子</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main  <span class="comment">// 定义包名 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span>  <span class="comment">// 引入包</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123; </span><br><span class="line">   <span class="comment">/* 这是我的第一个简单的程序 */</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;Hello, World!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="关于包名的注解">关于包名的注解</h3>
<ul>
<li>文件名与包名没有直接关系，不一定要将文件名与包名定成同一个。</li>
<li>文件夹名与包名没有直接关系，并非需要一致。</li>
<li>同一个文件夹下的文件只能有一个包名，否则编译报错。</li>
</ul>
<h4 id="文件结构">文件结构</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Test</span><br><span class="line">--helloworld.go</span><br><span class="line"></span><br><span class="line">myMath</span><br><span class="line">--myMath1.go</span><br><span class="line">--myMath2.go</span><br></pre></td></tr></table></figure>
<h4 id="测试代码">测试代码</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// helloworld.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;./myMath&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Hello World!&quot;</span>)</span><br><span class="line">    fmt.Println(mathClass.Add(<span class="number">1</span>,<span class="number">1</span>))</span><br><span class="line">    fmt.Println(mathClass.Sub(<span class="number">1</span>,<span class="number">1</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// myMath1.go</span></span><br><span class="line"><span class="keyword">package</span> mathClass</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span><span class="params">(x,y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// myMath2.go</span></span><br><span class="line"><span class="keyword">package</span> mathClass</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sub</span><span class="params">(x,y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x - y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="go-程序的一般结构-basic_structure.go">Go 程序的一般结构: basic_structure.go</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当前程序的包名</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入其他包</span></span><br><span class="line"><span class="keyword">import</span> . <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 常量定义：通过 const 关键字来进行常量的定义。</span></span><br><span class="line"><span class="keyword">const</span> PI = <span class="number">3.14</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局变量的声明和赋值：在函数体外部使用 var 关键字来进行全局变量的声明和赋值。</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;gopher&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一般类型声明</span></span><br><span class="line"><span class="keyword">type</span> newType <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 结构的声明：通过 type 关键字来进行结构(struct)的声明。</span></span><br><span class="line"><span class="keyword">type</span> gopher <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口的声明：通过 type 关键字来进行接口(interface)的声明。</span></span><br><span class="line"><span class="keyword">type</span> golang <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由main函数作为程序入口点启动</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Println(<span class="string">&quot;Hello World!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="通过-package-来组织">通过 package 来组织</h3>
<ul>
<li>只有 package 名称为 main 的包可以包含 main 函数。</li>
<li>一个可执行程序有且仅有一个 main 包。</li>
<li>通过 import 关键字来导入其他非 main 包。</li>
</ul>
<h4 id="可以通过-import-关键字单个导入">可以通过 import 关键字单个导入</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;io&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="可以同时导入多个">可以同时导入多个</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(math.Exp2(<span class="number">10</span>))  <span class="comment">// 1024</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用-packagename.functionname-导入调用">使用 <code>&lt;PackageName&gt;.&lt;FunctionName&gt;</code> 导入调用</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="comment">// 为fmt起别名为fmt2</span></span><br><span class="line"><span class="keyword">import</span> fmt2 <span class="string">&quot;fmt&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="省略调用不建议使用">省略调用(不建议使用)</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 调用的时候只需要Println()，而不需要fmt.Println()</span></span><br><span class="line"><span class="keyword">import</span> . <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    Println(<span class="string">&quot;hello,world&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="可见性规则">可见性规则</h3>
<ul>
<li>Go语言中，使用大小写来决定该常量、变量、类型、接口、结构或函数是否可以被外部包所调用。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数名首字母小写即为 private :</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getId</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"><span class="comment">//函数名首字母大写即为 public :</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Printf</span><span class="params">()</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>【Java】jdk11 的安装（Mac &amp; Windows）</title>
    <url>/2021/07/02/%E3%80%90Java%E3%80%91jdk11-%E7%9A%84%E5%AE%89%E8%A3%85%EF%BC%88Mac-Windows%EF%BC%89/</url>
    <content><![CDATA[<blockquote>
<p>此博客主要介绍了 Windows 和 Mac 系统下安装 jdk11 的简要步骤。</p>
</blockquote>
<span id="more"></span>
<h2 id="java-jdk11-的安装windows">Java-jdk11 的安装（Windows）</h2>
<ul>
<li><a href="https://www.oracle.com/java/technologies/javase-jdk11-downloads.html">下载 jdk11</a>
<ul>
<li>可能需要 Oracle 账号密码。</li>
</ul></li>
<li>直接安装，可以换安装路径。</li>
<li>设置环境变量。
<ul>
<li><a href="https://blog.csdn.net/qq_22136439/article/details/103295019">参考</a></li>
</ul></li>
<li>生成 jre 文件。</li>
<li>关于下载。
<ul>
<li><a href="https://blog.csdn.net/jzycloud/article/details/114123530">下载链接</a></li>
</ul></li>
</ul>
<h2 id="java-jdk11-的安装mac">Java-jdk11 的安装（Mac）</h2>
<ul>
<li><a href="https://www.oracle.com/java/technologies/javase-jdk11-downloads.html">下载</a></li>
<li>安装，<a href="https://www.jianshu.com/p/6273e7ab0c56">参考</a></li>
<li>Terminal 设置环境。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span>  /Library/Java/JavaVirtualMachines</span><br><span class="line">$ ls -la</span><br></pre></td></tr></table></figure>
<ul>
<li>编辑环境变量。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ vim  ~/.bash_profile</span><br><span class="line"><span class="comment">###</span></span><br><span class="line"><span class="comment"># 设置 jdk 8</span></span><br><span class="line"><span class="built_in">export</span> JAVA_8_HOME=`/usr/libexec/java_home -v 1.8`</span><br><span class="line"><span class="comment"># 设置 jdk 11</span></span><br><span class="line"><span class="built_in">export</span> JAVA_11_HOME=<span class="string">&quot;<span class="subst">$(/usr/libexec/java_home -v 11)</span>&quot;</span></span><br><span class="line"><span class="comment"># 默认JDK 8</span></span><br><span class="line"><span class="built_in">export</span> JAVA_HOME=<span class="variable">$JAVA_11_HOME</span></span><br><span class="line"><span class="comment">#alias命令动态切换JDK版本</span></span><br><span class="line"><span class="built_in">alias</span> jdk8=<span class="string">&quot;export JAVA_HOME=<span class="variable">$JAVA_8_HOME</span>&quot;</span></span><br><span class="line"><span class="built_in">alias</span> jdk11=<span class="string">&#x27;export JAVA_HOME=$JAVA_11_HOME&#x27;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>保存内容并退出，生效。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">source</span>  ~/.bash_profile</span><br><span class="line"><span class="comment"># 测试</span></span><br><span class="line">$ java -version</span><br><span class="line">$ jdk8</span><br><span class="line">$ java -version</span><br><span class="line">$ jdk11</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>【Python】Effective Python</title>
    <url>/2021/07/16/%E3%80%90Python%E3%80%91Effective-Python/</url>
    <content><![CDATA[<blockquote>
<p>本文记录了《Effective Python》的重要内容。</p>
</blockquote>
<span id="more"></span>
<h1 id="pythonic-确认自己所用的-python-版本">Pythonic-确认自己所用的 Python 版本</h1>
<h2 id="查看版本">查看版本</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python --version</span><br></pre></td></tr></table></figure>
<h2 id="sys-模块内查询">sys 模块内查询</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.version_info</span><br><span class="line">sys.version_info(major=<span class="number">3</span>, minor=<span class="number">6</span>, micro=<span class="number">8</span>, releaselevel=<span class="string">&#x27;final&#x27;</span>, serial=<span class="number">0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.version</span><br><span class="line"><span class="string">&#x27;3.6.8 |Anaconda custom (64-bit)| (default, Dec 29 2018, 19:04:46) \n[GCC 4.2.1 Compatible Clang 4.0.1 (tags/RELEASE_401/final)]&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br></pre></td></tr></table></figure>
<p><code>优先考虑 Python3 版本！</code></p>
<h1 id="pythonic-遵循-pep-8-风格指南">Pythonic-遵循 PEP 8 风格指南</h1>
<h2 id="pep-8-的意义">PEP 8 的意义</h2>
<blockquote>
<p>《Python Enhancement Proposal 8》又叫 PEP 8，它是针对 Python 代码格式而编制的风格指南。</p>
<p><a href="https://www.python.org/dev/peps/pep-0008/">链接</a>：https://www.python.org/dev/peps/pep-0008/</p>
</blockquote>
<ul>
<li>主要作用：
<ul>
<li>有利于编写更加通俗易懂的代码。</li>
<li>有利于多人协作，有利于修改。</li>
</ul></li>
</ul>
<h2 id="几条重要的规则">几条重要的规则</h2>
<h3 id="命名">命名</h3>
<ul>
<li><code>函数、变量以及属性</code>应该用小写字母来拼写。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum_a_</span>+<span class="title">_b</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>):</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<ul>
<li><code>类</code>与异常，应该以每个单词首字母大写的形式来命名。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmallCar</span>():</span></span><br><span class="line">    ...</span><br><span class="line"><span class="comment">#</span></span><br><span class="line">CapitalizedWord</span><br></pre></td></tr></table></figure>
<ul>
<li><code>模块级别的常量</code>，应该全部采用大写字母来拼写，各单词下划线连接。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ALL_CAPS</span><br></pre></td></tr></table></figure>
<ul>
<li><code>受保护的实例属性</code>，应该以单个下划线开头。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">_leading_underscore</span><br></pre></td></tr></table></figure>
<ul>
<li><code>私有的实例属性</code>，应该以两个下划线开头。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">__double_leading_underscore</span><br></pre></td></tr></table></figure>
<h3 id="空白">空白</h3>
<ul>
<li>在变量赋值的时候，赋值符号的左侧和右侧应该各自写上一个空格。</li>
<li>文件中的 函数 和 类 之间应该用两个空行隔开。</li>
<li>在同一个类中，各方法 之间应该用一个空行隔开。</li>
<li>对于占据多行的长表达式来说，除了首行之外的其余各行都应该在通常的缩进级别之上再加4个空格。</li>
</ul>
<h3 id="表达式和语句">表达式和语句</h3>
<ul>
<li>不要用 <code>if len(a) == 0</code> 来判断 <code>a</code> 列表是否为空值。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> a: <span class="comment"># 判断 a 是空</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">if</span> a: <span class="comment"># 判断 a 不空</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<ul>
<li>采用内联形式的否定词，而不是把否定词放到整个表达式前面。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> a <span class="keyword">is</span> <span class="keyword">not</span> b: <span class="comment"># 推荐</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> a <span class="keyword">is</span> b: <span class="comment"># 不推荐</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>不要编写单行的 if 语句、for 循环、while 循环及 except 复合语句。</p></li>
<li>import
<ul>
<li>import 语句总是放在文件开头。</li>
<li>import 语句根据顺序分为三个部分：
<ul>
<li>标准库模块</li>
<li>第三方模块</li>
<li>自用模块</li>
</ul></li>
<li>在每一模块中，按照字母顺序排列。</li>
</ul></li>
</ul>
<blockquote>
<p><a href="http://www.pylint.org">Pylint</a> 流行的 Python 源码静态分析工具。</p>
<p>它可以自动检测受测代码是否符合 PEP 8 的风格。</p>
</blockquote>
<h1 id="pythonic-了解-bytesstr-与-unicode-区别">Pythonic-了解 bytes、str 与 unicode 区别</h1>
<h2 id="字符序列类型">字符序列类型</h2>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">字符序列类型</th>
<th style="text-align: center;">Python 3</th>
<th style="text-align: center;">Python 2</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">8位值 (8个二进制)</td>
<td style="text-align: center;">bytes</td>
<td style="text-align: center;">str</td>
</tr>
<tr class="even">
<td style="text-align: center;">Unicode 字符</td>
<td style="text-align: center;">str</td>
<td style="text-align: center;">unicode</td>
</tr>
</tbody>
</table>
<blockquote>
<p>Unicode 字符（Python 3 的 str 实例和 Python 2 的 unicode 实例）都没有和特定的二进制编码形式相关联；</p>
<p>换句话说，Unicode字符 转换为 二进制数据 有很多编码方式，其中最常见的是 UTF-8。</p>
</blockquote>
<h2 id="编码与解码">编码与解码</h2>
<ul>
<li>Unicode 字符 --&gt; 二进制数据，称为编码 encode</li>
<li>二进制数据 --&gt; Unicode 字符，称为解码 decode</li>
</ul>
<blockquote>
<p>编写 Python 程序的时候，一定要把编码和解码放在最外围来做。</p>
</blockquote>
<h2 id="使用情形python-3">使用情形（Python 3）</h2>
<ul>
<li>使用情形
<ul>
<li>需要将 <strong>Unicode 字符</strong> --&gt; UTF-8 编码后的<strong>二进制数据</strong></li>
<li>需要操作没有特定编码形式的 Unicode字符</li>
</ul></li>
<li>解码</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">to_str</span>(<span class="params">bytes_or_str</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(bytes_or_str, <span class="built_in">bytes</span>):</span><br><span class="line">        value = bytes_or_str.decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        value = bytes_or_str</span><br><span class="line">    <span class="keyword">return</span> value <span class="comment"># Instance of str</span></span><br></pre></td></tr></table></figure>
<ul>
<li>编码</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">to_str</span>(<span class="params">bytes_or_str</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(bytes_or_str, <span class="built_in">str</span>):</span><br><span class="line">        value = bytes_or_str.encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        value = bytes_or_str</span><br><span class="line">    <span class="keyword">return</span> value <span class="comment"># Instance of bytes</span></span><br></pre></td></tr></table></figure>
<h2 id="可能的问题python-3">可能的问题（Python 3）</h2>
<blockquote>
<p>如果使用内置函数 open 获取了文件句柄（file handle）。那么请注意，该句柄默认采用 UTF-8 的编码格式来操作文件。</p>
</blockquote>
<ul>
<li>问题：如果向文件中随机写入一些二进制数据，下面代码可能会出错。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;/tmp/random.bin&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)<span class="keyword">as</span> f:</span><br><span class="line">    f.write(os.urandom(<span class="number">10</span>))</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">TypeError: must be <span class="built_in">str</span>, <span class="keyword">not</span> <span class="built_in">bytes</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>原因：Python 3 给 open 函数添加了名为 encoding 的新参数，而这个参数的默认值就是 'utf-8'。</p></li>
<li><p>解决方案，用二进制写入模式（'wb'）来开启待操作的文件。</p></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;/tmp/random.bin&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>)<span class="keyword">as</span> f:</span><br><span class="line">    f.write(os.urandom(<span class="number">10</span>))</span><br></pre></td></tr></table></figure>
<ul>
<li>读取数据也类似，用（'rb'）来打开文件。</li>
</ul>
<h1 id="pythonic-用辅助函数来替代复杂式">Pythonic-用辅助函数来替代复杂式</h1>
<blockquote>
<p>在处理网页，或者说处理字符串时，我们经常获得到一个字典，对于字典里的键值对的处理挺关键的。然而有些朋友过度使用 Python 的语法特性，为了炫技，写成很复杂的难以理解的单行表达式，就有点小题大做了。</p>
</blockquote>
<ul>
<li>比如这样一个栗子。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> parse_qs</span><br><span class="line"><span class="comment"># 解析字符串，返回字典</span></span><br><span class="line">my_value = parse_qs(<span class="string">&#x27;red=5&amp;blue=0&amp;green=&#x27;</span>, keep_blank_values=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(my_value)</span><br><span class="line"><span class="comment"># &#123;&#x27;red&#x27;: [&#x27;5&#x27;], &#x27;blue&#x27;: [&#x27;0&#x27;], &#x27;green&#x27;: [&#x27;&#x27;]&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>对于上面待处理的字典，我们对其值感兴趣。</li>
<li>也就是我们想查询我们需要的值。</li>
<li>现在一个目标是，若待查询的参数没有出现在字符串中，我们希望返回默认值 0，而不返回 None 等。该如何处理呢？
<ul>
<li>也许我们会考虑 dic.get(key, defalt=None)</li>
<li>key 指代键，如果查不到对应值，返回第二个参数 None</li>
</ul></li>
<li>对于想要的目标，我们做出以下一步步调试。</li>
</ul>
<h2 id="复杂方式_1">复杂方式_1</h2>
<ul>
<li>空字符串、空列表及零值，都会评估为 False。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># For query string &#x27;red=5&amp;blue=0&amp;green=&#x27;</span></span><br><span class="line">red = my_value.get(<span class="string">&#x27;red&#x27;</span>, [<span class="string">&#x27;&#x27;</span>])[<span class="number">0</span>] <span class="keyword">or</span> <span class="number">0</span> <span class="comment"># or 操作符</span></span><br><span class="line">green = my_value.get(<span class="string">&#x27;green&#x27;</span>, [<span class="string">&#x27;&#x27;</span>])[<span class="number">0</span>] <span class="keyword">or</span> <span class="number">0</span> <span class="comment"># 如果 or 前判断 False</span></span><br><span class="line">opacity = my_value.get(<span class="string">&#x27;opacity&#x27;</span>, [<span class="string">&#x27;&#x27;</span>])[<span class="number">0</span>] <span class="keyword">or</span> <span class="number">0</span> <span class="comment"># 赋值 or 后语句</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Red:     %r&#x27;</span> %red) <span class="comment"># %r 用 rper()方法处理对象</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;green:   %r&#x27;</span> %green) <span class="comment"># 打印时能够重现它所代表的对象</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;opacity: %r&#x27;</span> %opacity)</span><br><span class="line"><span class="comment"># Red:     &#x27;5&#x27;</span></span><br><span class="line"><span class="comment"># green:   0</span></span><br><span class="line"><span class="comment"># opacity: 0</span></span><br></pre></td></tr></table></figure>
<h2 id="炫技方式_2">炫技方式_2</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">red_1 = my_value.get(<span class="string">&#x27;red&#x27;</span>, [<span class="string">&#x27;&#x27;</span>])</span><br><span class="line">red_1 = <span class="built_in">int</span>(red_1[<span class="number">0</span>]) <span class="keyword">if</span> red_1[<span class="number">0</span>] <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line"><span class="built_in">print</span>(red_1)</span><br><span class="line"><span class="comment"># 5</span></span><br></pre></td></tr></table></figure>
<h2 id="简单方式_3">简单方式_3</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">green_1 = my_value.get(<span class="string">&#x27;green&#x27;</span>, [<span class="string">&#x27;&#x27;</span>])</span><br><span class="line"><span class="keyword">if</span> green_1[<span class="number">0</span>]: <span class="comment"># 如果有值</span></span><br><span class="line">    green_1 = <span class="built_in">int</span>(green_1[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    green_1 = <span class="number">0</span></span><br><span class="line"><span class="built_in">print</span>(green_1)</span><br><span class="line"><span class="comment"># 0</span></span><br></pre></td></tr></table></figure>
<h2 id="范式_4">范式_4</h2>
<ul>
<li>用简单函数的表示来取代复杂的表达式。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_int_value</span>(<span class="params">dic_kv, key, default=<span class="number">0</span></span>):</span></span><br><span class="line">    value = dic_kv.get(key, [<span class="string">&#x27;&#x27;</span>])</span><br><span class="line">    <span class="keyword">if</span> value[<span class="number">0</span>]:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(value[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> default</span><br><span class="line"><span class="built_in">print</span>(get_int_value(my_value, <span class="string">&#x27;opacity&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(get_int_value(my_value, <span class="string">&#x27;red&#x27;</span>))</span><br><span class="line"><span class="comment"># 0</span></span><br><span class="line"><span class="comment"># 5</span></span><br></pre></td></tr></table></figure>
<h1 id="pythonic-了解切割序列的办法">Pythonic-了解切割序列的办法</h1>
<blockquote>
<p>Python 提供了一种把序列切成小块的方法。 针对内置的 list、str 和 bytes 的切割。</p>
</blockquote>
<h2 id="切割序列">切割序列</h2>
<ul>
<li>一个列表</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list_num = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0</span>]</span><br><span class="line"><span class="comment">#  index =  0, 1, 2, 3, 4, 5, 6, 7, 8, 9</span></span><br><span class="line"><span class="comment">#  index = -0(-10),-9,-8,-7,-6,-5,-4,-3,-2,-1 </span></span><br></pre></td></tr></table></figure>
<ul>
<li>正常的切割序列 <code>[start_index:end_index]</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(list_num[:])</span><br><span class="line"><span class="comment"># print all [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(list_num[<span class="number">1</span>:<span class="number">4</span>])</span><br><span class="line"><span class="comment"># index-123 [2, 3, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(list_num[<span class="number">2</span>:])</span><br><span class="line"><span class="comment"># index-2... [3, 4, 5, 6, 7, 8, 9, 0]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(list_num[:<span class="number">8</span>])</span><br><span class="line"><span class="comment"># index-...7 [1, 2, 3, 4, 5, 6, 7, 8]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(list_num[<span class="number">7</span>:<span class="number">2</span>])</span><br><span class="line"><span class="comment"># if start_index &gt; end_index []</span></span><br></pre></td></tr></table></figure>
<ul>
<li>负值切割</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(list_num[-<span class="number">4</span>:-<span class="number">2</span>])</span><br><span class="line"><span class="comment"># index~-4,-3 [7, 8]</span></span><br><span class="line"><span class="built_in">print</span>(list_num[-<span class="number">4</span>:])</span><br><span class="line"><span class="comment"># index~-4... [7, 8, 9, 0]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(list_num[-<span class="number">0</span>:])</span><br><span class="line"><span class="comment"># print all [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]</span></span><br><span class="line"><span class="built_in">print</span>(list_num[-<span class="number">12</span>:])</span><br><span class="line"><span class="comment"># print all [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(list_num[-<span class="number">1</span>:<span class="number">0</span>])</span><br><span class="line"><span class="comment"># if start_index &gt; end_index []</span></span><br><span class="line"><span class="built_in">print</span>(list_num[-<span class="number">1</span>:-<span class="number">1</span>])</span><br><span class="line"><span class="comment"># []</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(list_num[-<span class="number">1</span>:])</span><br><span class="line"><span class="comment"># [0]</span></span><br><span class="line"><span class="built_in">print</span>(list_num[-<span class="number">12</span>:<span class="number">6</span>])</span><br><span class="line"><span class="comment"># [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure>
<h2 id="传值">传值</h2>
<ul>
<li>对于元组而言，传值纬度 必须保持一致。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">c = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0</span>]</span><br><span class="line">c1, c2 = c[<span class="number">2</span>:<span class="number">4</span>]</span><br><span class="line"><span class="built_in">print</span>(c1, c2)</span><br><span class="line"><span class="comment"># 3 4</span></span><br><span class="line"></span><br><span class="line">c3, c4 = c[<span class="number">5</span>:<span class="number">8</span>]</span><br><span class="line"><span class="built_in">print</span>(c3, c4)</span><br><span class="line"><span class="comment"># ValueError: too many values to unpack (expected 2)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>不同于元组，列表的切片不考虑纬度，可以伸缩。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">a[<span class="number">2</span>:<span class="number">4</span>] = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="comment"># index_start: 2 扩张</span></span><br><span class="line"><span class="comment"># [1, 2, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, 5, 6, 7, 8, 9, 0]</span></span><br><span class="line"></span><br><span class="line">b =  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0</span>]</span><br><span class="line">b[<span class="number">2</span>:<span class="number">7</span>] = [<span class="string">&#x27;123&#x27;</span>,<span class="string">&#x27;456&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="comment"># index_start: 2 缩减</span></span><br><span class="line"><span class="comment"># [1, 2, &#x27;123&#x27;, &#x27;456&#x27;, 8, 9, 0]</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>【Python】修饰器总结</title>
    <url>/2021/08/25/%E3%80%90Python%E3%80%91%E4%BF%AE%E9%A5%B0%E5%99%A8%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<blockquote>
<p>总结一些遇到过的有意思的修饰器。</p>
</blockquote>
<span id="more"></span>
<h1 id="property"><span class="citation" data-cites="property">@property</span></h1>
<blockquote>
<p>将方法变成属性调用。</p>
</blockquote>
<h2 id="一般类及问题">一般类及问题</h2>
<ul>
<li>有这样一个类，能够展现一个陌生人的基本信息。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stranger</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, gender=<span class="literal">None</span>, age=<span class="literal">None</span>, job=<span class="literal">None</span></span>):</span></span><br><span class="line">        self.gender = gender</span><br><span class="line">        self.age = age</span><br><span class="line">        self.jobb = job</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># 创建一个“妹子”</span></span><br><span class="line">    meizi = Stranger()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设置妹子的属性</span></span><br><span class="line">    meizi.gender = <span class="string">&quot;female&quot;</span></span><br><span class="line">    meizi.age = <span class="number">18</span></span><br><span class="line">    meizi.job = <span class="string">&quot;teacher&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 访问妹子的属性</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;妹子信息:&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;性别:&#123;gender&#125;&quot;</span>.<span class="built_in">format</span>(gender=meizi.gender))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;年龄:&#123;age&#125;&quot;</span>.<span class="built_in">format</span>(age=meizi.age))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;职业:&#123;job&#125;&quot;</span>.<span class="built_in">format</span>(job=meizi.job))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment">#妹子信息:</span></span><br><span class="line"><span class="comment">#性别:female</span></span><br><span class="line"><span class="comment">#年龄:18</span></span><br><span class="line"><span class="comment">#职业:teacher</span></span><br></pre></td></tr></table></figure>
<ul>
<li>但可能会产生一个问题：输出的结果<code>异常</code>。
<ul>
<li>原因是属性的值得范围并未做明确的设定。</li>
</ul></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># 创建一个“妹子”</span></span><br><span class="line">    meizi = Stranger()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设置妹子的属性</span></span><br><span class="line">    meizi.gender = <span class="string">&quot;beijing&quot;</span></span><br><span class="line">    meizi.age = <span class="string">&quot;teacher&quot;</span></span><br><span class="line">    meizi.job = <span class="number">20</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 访问妹子的属性</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;妹子信息:&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;性别:&#123;gender&#125;&quot;</span>.<span class="built_in">format</span>(gender=meizi.gender))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;年龄:&#123;age&#125;&quot;</span>.<span class="built_in">format</span>(age=meizi.age))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;职业:&#123;job&#125;&quot;</span>.<span class="built_in">format</span>(job=meizi.job))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment">#妹子信息:</span></span><br><span class="line"><span class="comment">#性别:beijing</span></span><br><span class="line"><span class="comment">#年龄:teacher</span></span><br><span class="line"><span class="comment">#职业:20</span></span><br></pre></td></tr></table></figure>
<h2 id="普通解决方案">普通解决方案</h2>
<ul>
<li>一个比较简单的解决方案就是对值的范围进行设定。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Stranger(object):</span><br><span class="line">    def __init__(self, gender=None, age=None, job=None):</span><br><span class="line">        self.gender = gender</span><br><span class="line">        self.age = age</span><br><span class="line">        self.jobb = job</span><br><span class="line">        </span><br><span class="line">    # 设置age</span><br><span class="line">    def set_age(self, age):</span><br><span class="line">        if isinstance(age, int):</span><br><span class="line">            self.age = age</span><br><span class="line">        else:</span><br><span class="line">        	raise ValueError(&quot;&#x27;int&#x27; type need&quot;)</span><br><span class="line">            </span><br><span class="line">    # 读取age</span><br><span class="line">    def get_age(self):</span><br><span class="line">        return self.age</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    # 创建一个“妹子”</span><br><span class="line">    meizi = Stranger()</span><br><span class="line"></span><br><span class="line">    meizi.set_age(18)</span><br><span class="line">    print(&quot;年龄:&#123;age&#125;&quot;.format(age=meizi.get_age()))</span><br><span class="line"></span><br><span class="line"># 输出：</span><br><span class="line">#年龄:18</span><br></pre></td></tr></table></figure>
<ul>
<li>此时如果值的范围不对，会报错。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">meizi.set_age(<span class="string">&quot;teacher&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;年龄:&#123;age&#125;&quot;</span>.<span class="built_in">format</span>(age=meizi.get_age()))</span><br><span class="line"><span class="comment"># ValueError: &#x27;int&#x27; type need</span></span><br></pre></td></tr></table></figure>
<ul>
<li>此时我们解决了这个问题，那么有没有更加简便的方法呢？</li>
</ul>
<h2 id="引入property">引入@property</h2>
<ul>
<li>为了避免麻烦，于是有了@property装饰器。它的作用是：将方法变成属性调用。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stranger</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, gender=<span class="literal">None</span>, age=<span class="literal">None</span>, job=<span class="literal">None</span></span>):</span></span><br><span class="line">        self.gender = gender</span><br><span class="line">        self._age = age <span class="comment"># 这里的成员属性_age需要与成员方法age()区分开</span></span><br><span class="line">        self.jobb = job</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 读取age</span></span><br><span class="line"><span class="meta">    @property </span><span class="comment"># 实现一个age相关的getter方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">age</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self._age</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设置age</span></span><br><span class="line"><span class="meta">    @age.setter </span><span class="comment"># 实现一个age相关的setter方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">age</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(value, <span class="built_in">int</span>):</span><br><span class="line">            self._age = value</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&quot;&#x27;int&#x27; type need&quot;</span>)</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># 创建一个“妹子”</span></span><br><span class="line">    meizi = Stranger()</span><br><span class="line"></span><br><span class="line">    meizi.age = <span class="number">18</span>  <span class="comment"># 使用时注意是.age，不是._age</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;年龄:&#123;age&#125;&quot;</span>.<span class="built_in">format</span>(age=meizi.age))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment">#年龄:18</span></span><br></pre></td></tr></table></figure>
<ul>
<li>注意！
<ul>
<li>属性名与方法名一定要区分开，不然会进入死循环
<ul>
<li>（self._age，def age()）</li>
</ul></li>
<li>实例化的对象使用属性时
<ul>
<li>不是调用属性（meizi._age），而是用的方法名（meizi.age）</li>
</ul></li>
<li><code>@property</code> 其实就是实现了 getter 功能；
<ul>
<li><code>@xxx.setter</code> 实现的是 setter 功能；</li>
<li>还有一个 <code>@xxx.deleter</code> 实现删除功能</li>
</ul></li>
<li>定义方法的时候 <code>@property</code> 必须在 <code>@xxx.setter</code>之前，
<ul>
<li>且二者修饰的方法名相同（age()）</li>
</ul></li>
<li>如果只实现了 <code>@property</code>（而没有实现 <code>@xxx.setter</code>），那么该属性为<code>只读属性</code></li>
</ul></li>
</ul>
<h2 id="property原理"><span class="citation" data-cites="property原理">@property原理</span></h2>
<p>函数接口：<code>property(fget=None, fset=None, fdel=None, doc=None)</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stranger</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, gender=<span class="literal">None</span>, age=<span class="literal">None</span>, job=<span class="literal">None</span></span>):</span></span><br><span class="line">        self.gender = gender</span><br><span class="line">        self._age = age</span><br><span class="line">        self.jobb = job</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设置_age</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_age</span>(<span class="params">self, age</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(age, <span class="built_in">int</span>):</span><br><span class="line">            self._age = age</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&quot;&#x27;int&#x27; type need&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 读取_age</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_age</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self._age</span><br><span class="line">	</span><br><span class="line">    <span class="comment"># 使得实例化对象可以利用.age方式来访问</span></span><br><span class="line">    age = <span class="built_in">property</span>(get_age, set_age)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># 创建一个“妹子”</span></span><br><span class="line">    meizi = Stranger()</span><br><span class="line"></span><br><span class="line">    meizi.age = <span class="number">18</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;年龄:&#123;age&#125;&quot;</span>.<span class="built_in">format</span>(age=meizi.age))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment">#年龄:18</span></span><br></pre></td></tr></table></figure>
<h2 id="参考">参考</h2>
<ul>
<li><span class="citation" data-cites="property的使用">[@property的使用]</span>(https://blog.csdn.net/qq_41359051/article/details/82939655)</li>
<li><a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017502538658208">使用@property</a></li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>修饰器</tag>
      </tags>
  </entry>
  <entry>
    <title>【hexo】Github + Hexo 搭建个人博客</title>
    <url>/2021/07/03/%E3%80%90hexo%E3%80%91Github-Hexo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<blockquote>
<p>用 Github + Hexo 搭建个人博客的简要步骤。</p>
</blockquote>
<span id="more"></span>
<h2 id="一github-创建个人仓库">一、Github 创建个人仓库</h2>
<ul>
<li>仓库名：<code>用户名</code>.github.io
<ul>
<li>必须是用户名！（如我的就是 <code>PzLu</code>.github.io）</li>
</ul></li>
<li>该仓库下的 Page 内容需要配置（为后续做准备）。</li>
</ul>
<h2 id="二安装-node.js">二、安装 Node.js</h2>
<ul>
<li>安装教程略。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ node -v</span><br><span class="line">$ npm -v</span><br></pre></td></tr></table></figure>
<h2 id="三安装-hexo">三、安装 hexo</h2>
<ul>
<li>创建一个文件夹，可以命名为 myBlog，Hexo框架与以后你自己发布的网页都在这个文件夹中。</li>
<li>可以用 vscode 打开，bash 终端操作执行。</li>
<li>安装 hexo</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install -g hexo-cli </span><br></pre></td></tr></table></figure>
<ul>
<li>初始化 blog</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo init blog</span><br></pre></td></tr></table></figure>
<h2 id="四下载配置自己喜欢的主题并适配">四、下载配置自己喜欢的主题并适配</h2>
<ul>
<li>我选择的是 NexT，参考 <a href="https://theme-next.js.org/docs/getting-started/">NexT Documentation</a></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> blog</span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/next-theme/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>
<ul>
<li>更换主题，选择 <code>blog</code> 下的 <code>_config.yml</code>，<code>theme</code> 改为 <code>next</code>，记得中间有空格。</li>
</ul>
<h2 id="五推送网站">五、推送网站</h2>
<ul>
<li>选择 <code>blog</code> 下的 <code>_config.yml</code>，<a href="https://pzlu.github.io/2021/07/03/%E3%80%90hexo%E3%80%91%E9%97%AE%E9%A2%98%EF%BC%9Aport-443-Timed-out/#more">更改格式，格式参考此问题下的解决方案</a>。</li>
<li>更改完成后，再安装 <code>hexo-deployer-git</code> 也不迟。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<ul>
<li>三步走战略
<ul>
<li>生成：<code>hexo g</code></li>
<li>部署：<code>hexo d</code></li>
</ul></li>
<li>去自己的网站看看 <code>用户名.github.io</code> （如我的 <code>pzlu.github.io</code>）</li>
</ul>
<hr />
<h2 id="六问题">六、问题</h2>
<ul>
<li>如何用 mac 和 windows 同时维护博客？
<ul>
<li>我测试了下，好像有些问题，windows 维护的博客，在 mac 上维护后主页会变成空白，目前还没发现问题在哪。</li>
</ul></li>
</ul>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/91652100">使用Github做一个完全免费的个人网站(步骤很细)</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/26625249">GitHub+Hexo 搭建个人网站详细教程</a></li>
<li><a href="https://hexo.io/docs/">Hexo Documentation</a></li>
<li><a href="https://theme-next.js.org/docs/getting-started/">NexT Documentation</a></li>
<li><a href="https://www.jianshu.com/p/484e4ca7edf0">在Mac上搭建基于Hexo的个人博客网站</a></li>
</ul>
]]></content>
      <categories>
        <category>个人博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>【hexo】迁移博客</title>
    <url>/2021/09/05/%E3%80%90hexo%E3%80%91%E8%BF%81%E7%A7%BB%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<blockquote>
<p>本文主要讲述两种迁移 hexo 博客的方式，仅供参考。hahahahahah</p>
</blockquote>
<span id="more"></span>
<h2 id="方式一主流方法">方式一（主流方法）</h2>
<ul>
<li>主流方法的好处在于只要在一个仓库开辟分支进行操作就行。
<ul>
<li><a href="https://www.cnblogs.com/itvdo/p/11323937.html">参考一</a></li>
<li><a href="https://segmentfault.com/a/1190000017265154">参考二</a><br />
</li>
</ul></li>
</ul>
<h2 id="方式二我的方法不是特别推荐">方式二（我的方法，不是特别推荐）</h2>
<ul>
<li>首先我的主页是 pzlu.github.io 这个仓库A；</li>
<li>然后我会把本地的有关这个仓库的文件上传到我的 github 的私人仓库B。
<ul>
<li>注意：这个上传的仓库，可能因为主题是外嵌包（会更新）的原因不能上传，
<ul>
<li>可通过一些操作将主题上传。</li>
</ul></li>
<li>简单地讲就是 theme 这个文件里的主题内容要另外备份。</li>
</ul></li>
<li>那么迁移的步骤就如下：
<ul>
<li>在新电脑上拉取 仓库B 的内容；</li>
<li>在 theme 文件中导入我的主题文件；</li>
<li>在新电脑上安装主要的对应模块的包并检查版本问题等；</li>
<li><code>hexo clean &amp;&amp; hexo g -d</code></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>【Tex】Texlive的安装</title>
    <url>/2021/08/04/%E3%80%90Tex%E3%80%91Texlive%E7%9A%84%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<blockquote>
<p>Texlive（Windows）的安装。</p>
</blockquote>
<span id="more"></span>
<blockquote>
<p>【TexLive 2020 安装指南】https://zhuanlan.zhihu.com/p/136931926</p>
<p>软件下载链接：https://mirrors.tuna.tsinghua.edu.cn/ctan/systems/texlive/Images/?C=M&amp;O=A 选择里面的 texlive2021.iso 进行下载~</p>
</blockquote>
<h1 id="双击-install-tl-windows.bat-进行安装">双击 install-tl-windows.bat 进行安装</h1>
<p><img src="https://user-images.githubusercontent.com/48743005/128168436-0f16b2c0-9512-436d-ae40-d2f19c3edb94.png" /> <img src="https://user-images.githubusercontent.com/48743005/128168460-5f11ffbf-3bea-4994-96e7-bc4e631ce14e.png" /></p>
<ul>
<li><code>tex --version</code>检查版本</li>
</ul>
<p><img src="https://user-images.githubusercontent.com/48743005/128168513-ede63eda-1085-4d20-ae18-d486375aadf0.png" /></p>
<h1 id="安装-vscode-插件">安装 VSCode 插件</h1>
<ul>
<li>安装 <code>Latex workshop</code> 插件</li>
</ul>
<p><img src="https://user-images.githubusercontent.com/48743005/128168532-4839e02e-d84e-4a18-8a9f-85367b28c3b4.png" /></p>
<h1 id="配置-vscode-的-settings.json">配置 VSCode 的 settings.json</h1>
<blockquote>
<p>注意，一定要事先安装好 SumatraPDF 这个小应用程序，否则无法完美预览 PDF。如果你不要求特别完美的跳转搜索，或者认为没有必要，也可以不安装。</p>
</blockquote>
]]></content>
      <categories>
        <category>Tex</category>
      </categories>
      <tags>
        <tag>Latex</tag>
        <tag>Tex</tag>
      </tags>
  </entry>
  <entry>
    <title>【hexo】问题：port 443: Timed out</title>
    <url>/2021/07/03/%E3%80%90hexo%E3%80%91%E9%97%AE%E9%A2%98%EF%BC%9Aport-443-Timed-out/</url>
    <content><![CDATA[<blockquote>
<p>hexo g -d 出现问题：port 443: Timed out</p>
</blockquote>
<span id="more"></span>
<h2 id="解决方案">解决方案</h2>
<ul>
<li>查看是否能连接 github</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ssh -T git@github.com</span><br><span class="line"><span class="comment"># Hi ...! You&#x27;ve successfully authenticated, but ... 则表示能连接</span></span><br></pre></td></tr></table></figure>
<ul>
<li>改配置：配置的Github远程仓库的地址最好使用SSH的地址。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># site root directory</span></span><br><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repo: ssh://git@github.com/pzlu/pzlu.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://segmentfault.com/q/1010000004682965/a-1020000004895413">hexo搭建博客过程中出现的问题</a></li>
</ul>
]]></content>
      <categories>
        <category>技术问题</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>技术问题</tag>
      </tags>
  </entry>
  <entry>
    <title>【专业成长】CV和Resume的区别</title>
    <url>/2021/08/04/%E3%80%90%E4%B8%93%E4%B8%9A%E6%88%90%E9%95%BF%E3%80%91CV%E5%92%8CResume%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<blockquote>
<p>CV 和 Resume 的区别。Résumé 倾向于个人简历，CV（Curriculum Vitae）更倾向个人履历。</p>
</blockquote>
<span id="more"></span>
<ul>
<li>在美国，求职一般用Résumé，CV主要用于申请学术、教育、科研职位；</li>
<li>在英国，求职通常用CV。</li>
</ul>
<h1 id="不同之处">不同之处</h1>
<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">层面</th>
<th style="text-align: center;">Resume</th>
<th style="text-align: center;">CV</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">长度</td>
<td style="text-align: center;">Résumé是个人技能、经历和教育的摘要，长度为1到2页，1页以内为佳。</td>
<td style="text-align: center;">CV的内容则需要更详细一些，至少2页，但也不要太长。</td>
</tr>
<tr class="even">
<td style="text-align: center;">个人信息</td>
<td style="text-align: center;">在 Résumé中，主要呈现个人的职业素养，不需要在底部写兴趣爱好。</td>
<td style="text-align: center;">在CV中，写完50词左右的personal statement之后，你还需要另起一段写写自己的爱好。</td>
</tr>
<tr class="odd">
<td style="text-align: center;">背景调查联系人</td>
<td style="text-align: center;">在 Résumé里没有空间留给References（背景调查联系人）。</td>
<td style="text-align: center;">在CV底部写好References。</td>
</tr>
</tbody>
</table>
<h1 id="resume-内容">Resume 内容</h1>
<h2 id="应包含信息">应包含信息</h2>
<ul>
<li>Title
<ul>
<li>在Résumé的上方中间位置，用大写字母写上你的名字。在名字的下面，用小写字母写上你的地址、手机号和电子邮箱。</li>
</ul></li>
<li>Background
<ul>
<li>这一部分以educational background或professional background开头都可以，二者都要独立成区。如果是求职跳槽的话，建议把professional放在前面。</li>
<li>educational部分，需要列出你毕业的学校以及拿到的学位；professional部分，建议只列出和目标岗位相关的工作经历。</li>
<li>比如你想申请一份会计职位，就要把简历中在餐厅当服务员的经历删掉，因为这些不相关的信息，对给简历加分毫无帮助，只会浪费空间。</li>
</ul></li>
<li>Skills Section
<ul>
<li>在此处列出你拥有的电脑技能、或语言技能。如果有课外活动或社区服务经历，也加进去。后面可以简短附上你的爱好。</li>
</ul></li>
</ul>
<h2 id="不应该包含信息">不应该包含信息</h2>
<ul>
<li>No Photos
<ul>
<li>很多时候大家喜欢在简历上放照片，但如果你应聘欧美企业，则不要放照片。否则，你的简历可能因为放了照片而被刷掉。</li>
<li>这是为了在招聘时避免种族歧视。</li>
</ul></li>
<li>Minimal Personal Info
<ul>
<li>Résumé中不需要包含年龄、性别、国籍、婚否这些细小的个人信息。底部的Personal Info中，顶多写写你的兴趣爱好，比如旅行或厨艺。</li>
</ul></li>
</ul>
<h1 id="cv-内容">CV 内容</h1>
<h2 id="应包含信息-1">应包含信息</h2>
<ul>
<li>Title
<ul>
<li>这部分和Résumé是一样的。在CV上方中间位置，用大写字母写上你的名字。在名字的下面，用小写字母写上你的地址、手机号和电子邮箱。</li>
</ul></li>
<li>Personal Statement
<ul>
<li>在这个部分，写一段描述自己的文字。把你学生阶段、实习阶段以及全职工作中取得的成就都写进去，以及如果成功进入应聘公司、你可以带来什么贡献。</li>
<li>这部分内容，写在Title部分的下面。</li>
</ul></li>
<li>Skills Section
<ul>
<li>在这部分，把你拥有的亮眼技能都写进去。比如打字速度快、会使用HTML代码、语言技能等。</li>
</ul></li>
<li>Background
<ul>
<li>CV和Résumé最大的区别，就是不受长度限制。教育背景和职场经历写的内容可以多一些，但最多3-4页、不要再长了。</li>
<li>如果写完之后你发现自己的CV太长，就把那些次重要的信息删掉。</li>
</ul></li>
<li>Hobbies
<ul>
<li>在CV的Hobbies部分，你需要用一段话描述自己参与过的业余活动，长度50-70词。</li>
<li>无论是你的旅行经历、跨文化交流还是志愿活动，只要能体现你个人特色和气质的，都可以加进去。</li>
</ul></li>
<li>References
<ul>
<li>最后，你需要写几个供新雇主做背景调查的联系人，比如你的上一任老板、同事、朋友等。</li>
<li>写上他们的姓名、手机号、电子邮箱，以及和你的关系。</li>
</ul></li>
</ul>
<h2 id="不应包含信息">不应包含信息</h2>
<ul>
<li>Photo</li>
</ul>
]]></content>
      <categories>
        <category>成长</category>
      </categories>
      <tags>
        <tag>专业成长</tag>
      </tags>
  </entry>
  <entry>
    <title>【专业成长】个人推荐目录</title>
    <url>/2021/07/15/%E3%80%90%E4%B8%93%E4%B8%9A%E6%88%90%E9%95%BF%E3%80%91%E4%B8%AA%E4%BA%BA%E6%8E%A8%E8%8D%90%E7%9B%AE%E5%BD%95/</url>
    <content><![CDATA[<blockquote>
<p>个人专业学习过程中对好的作品的推荐。</p>
</blockquote>
<span id="more"></span>
<h1 id="书籍推荐">书籍推荐</h1>
<h2 id="机器学习">机器学习</h2>
<ul>
<li><a href="https://item.jd.com/12522197.html">《统计学习方法（第2版）》李航</a></li>
<li><a href="https://item.jd.com/12762673.html">《机器学习》周志华</a></li>
</ul>
<h2 id="深度学习">深度学习</h2>
<h3 id="深度学习入门">深度学习入门</h3>
<ul>
<li><a href="https://item.jd.com/12403048.html">《深度学习入门 基于 Python 的理论与实现》斋藤康毅</a></li>
<li><a href="https://item.jd.com/12851292.html">《神经网络与深度学习》邱锡鹏</a></li>
<li><a href="https://item.jd.com/12615065.html">《深入浅出图神经网络 GNN 原理解析》刘忠雨</a></li>
</ul>
]]></content>
      <categories>
        <category>成长</category>
      </categories>
      <tags>
        <tag>专业成长</tag>
      </tags>
  </entry>
  <entry>
    <title>【个人成长】自我成长</title>
    <url>/2021/07/05/%E3%80%90%E4%B8%AA%E4%BA%BA%E6%88%90%E9%95%BF%E3%80%91%E8%87%AA%E6%88%91%E6%88%90%E9%95%BF/</url>
    <content><![CDATA[<blockquote>
<p>自我探索与人格成长。</p>
</blockquote>
<span id="more"></span>
<h1 id="初级阶段">初级阶段</h1>
<h2 id="自我认同">自我认同</h2>
<blockquote>
<p>自我认同：你离找到自己还有多远？</p>
</blockquote>
<ul>
<li><strong>自我认同</strong>：一个人能够对于自己是一个怎样的人，将要去向何方，以及自己与社会的关系，有一种相对稳定且连续的认知的一种状态。</li>
<li>在探索自我的过程中，有四种不同的状态，包括早闭、混乱、<strong>延缓</strong>和达成。</li>
<li>三个因素会影响自我认同的发展：
<ul>
<li>外部的家庭因素、社会环境因素，它们影响了我们是否能够探索自我的机会和空间。</li>
<li>内部的自主性因素，它影响了我们是否有探索自我的意愿。</li>
</ul></li>
<li>为了达成自我认同：<strong>你必须持续地探索，在选择和尝试中发现自己真实的样子。</strong></li>
</ul>
<blockquote>
<p>你觉得自己当前在早闭、混乱、延缓、达成这四种状态的哪一种？</p>
<p>Ans: 延缓吧，我也一直在探索自己真实的样子，真实的自我。</p>
</blockquote>
<h2 id="真我假我">真我假我</h2>
<blockquote>
<p>真我假我：为什么有些人总是带着面具？</p>
</blockquote>
<ul>
<li>人有真我和假我。
<ul>
<li>真我，是一种对于自我的自发、真诚的体验。</li>
<li>假我是我们为了达到外界的要求、符合外界期待所发展出来的自我。</li>
</ul></li>
<li>假我最初源于婴儿早期和母亲的互动，在人的成长过程中不断地发展。</li>
<li><p><strong>假我太大，会让人看不见真实的自我。</strong></p></li>
<li>可以通过 3 个问题来分辨自己身上假我的部分：
<ul>
<li>你有哪些身份，这些身份需要你有什么样的表现？（儿子，学生）</li>
<li>你的性格或者为人处世曾经受过什么指责？（过于逃避问题，拖延症）</li>
<li>在拥有上面讲到的身份，或者遭到指责之前，你有着什么样的性格，而有了身份转变，或者遭到指责之后，自己有什么样的改变？你觉得这些改变困难吗?</li>
</ul></li>
</ul>
<blockquote>
<p>请你思考一下这最后提到的，分辨假我的 3 个问题。</p>
<p>Ans: 1、儿子，学生，朋友； 2、过于喜欢解释，过于挑剔，拖延症重度患者，说的比做的多等； 3、在逐渐改变这些不良恶习，不是很困难，就是挺难过的。</p>
</blockquote>
<h2 id="重要他人">重要他人</h2>
<blockquote>
<p>重要他人：重要他人如何影响我？</p>
</blockquote>
<ul>
<li>关系自我：我们在和重要他人的关系中所得出的，对于「我是一个什么样的人」这个问题的答案。
<ul>
<li>它包括了自我定义：比如「我是一个孝顺的人」</li>
<li>自我评价：比如「我是一个孝顺的人，这很好」</li>
<li>人格功能：比如「我做事一向严谨认真」</li>
<li>人际间的固定模式：它指的是我们在相应的人际关系中，倾向于产生什么样的感受和想法，以及做出什么样的行为反应。<br />
</li>
</ul></li>
<li>重要他人会通过影响我们的自我经验来影响关系自我，并且还会通过留下代表性形象，让在我们的生活中遇到对应的形象时，展现相应的关系自我。
<ul>
<li>我们可以通过形成新的自我经验来改变关系自我。</li>
</ul></li>
<li>如果想要主动地促成关系自我的改变，需要先了解改变的方向。比如通过自我觉察，去发现那些你想改变的关系自我，或者通过练习自我坚定的方法，降低重要他人对你的负面影响等等。</li>
</ul>
<blockquote>
<p>请你挑选一个你的重要他人，思考一下 Ta 在你的生命历程中，对你造成了怎样的影响。</p>
<p>Ans: 那必然是 77 了，她给了我很多关系角色，调动了我的情绪，给了我很大的情绪价值，也教会了我如何和女孩子长久地交际，我变得越来越会共情了，我不想她成为我的遗憾。</p>
</blockquote>
<h1 id="中级阶段">中级阶段</h1>
<h2 id="自我察觉">自我察觉</h2>
<blockquote>
<p>自我察觉：你真的了解自己吗？</p>
</blockquote>
<ul>
<li>自我觉察是一种能够<strong>清晰地认识自我的意愿和能力</strong>。</li>
<li>自我觉察需要从内部和外部深入，两者缺一不可。
<ul>
<li>了解我们自己是什么样的人，以及了解别人眼中的自己是怎样的。</li>
</ul></li>
<li>在自我觉察的过程中，我们需要警惕两大误区，
<ul>
<li>分别是优于平均效应和达克效应，
<ul>
<li>优于平均效应：也就是说我们自我觉察的水平可能并不如自己想象的那么高。</li>
<li>达克效应：能力越差的人可能反而自我感觉越良好。</li>
</ul></li>
<li>以及认知、情绪和行为上的三大盲区。
<ul>
<li>认知上的盲区会让我们对自己产生误解，而自我责备。</li>
<li>我们的大脑通常会选择最不费力气的方法来回答这个问题：你最近快乐吗？</li>
<li>我们不清楚自己在特定情境下的行为和表现。</li>
</ul></li>
</ul></li>
<li>自我觉察能力低的有四类人：
<ul>
<li>不愿付出的「实用主义者」，</li>
<li>无法自我接纳的人，</li>
<li>有一定成就的自恋者，</li>
<li>和情绪认知简单的人。</li>
</ul></li>
<li><strong>自我觉察是一件不容易的事情，是需要我们付出努力去锻炼的能力。</strong></li>
</ul>
<blockquote>
<p>你在自我觉察的过程中，通常会遇到哪些陷阱呢？</p>
<p>Ans: 优于平均效应，达克效应我都遇到过。 认知盲区，情绪盲区和行为盲区我也遇到过，绝了。。</p>
</blockquote>
<h2 id="自我察觉-1">自我察觉</h2>
<blockquote>
<p>自我察觉：六个方法帮你认识自我</p>
</blockquote>
<ul>
<li>几种错的自我觉察方式：
<ul>
<li>在内部自我觉察上，我们容易认为自我觉察就是思考，就是反复的去想自己的不好，以及经常问「为什么」。</li>
<li>在外部自我觉察上，我们容易认为能从亲近的人那里得到最准确的反馈，或者自认为自己才是最了解自己的人。</li>
</ul></li>
<li>正确提高自我觉察的方法有：
<ul>
<li>对内，建议你开始练习正念，多使用思维换框法，比较和对照法。</li>
<li>尝试改变叙事方式，重新了解过去的自我。
<ul>
<li>从不同人的角度去想，你就会发现这件事其实并没有一个唯一的事实，绝对的真实和真理是不存在的。</li>
</ul></li>
<li>对外，多寻找 360 度反馈和「对」的反馈，你还可以通过组织「晚餐桌上的真相」来了解别人眼中真实的自己。</li>
</ul></li>
</ul>
<blockquote>
<p>选择一种最适合自己的提升自我觉察的方法，想想你可以如何使用它来了解自己，写下自己的练习计划，并付诸行动吧。</p>
<p>练习正念，思维换框法。</p>
</blockquote>
<h2 id="自尊水平1">自尊水平1</h2>
<blockquote>
<p>自尊水平：为什么我总觉得自己不够好？</p>
</blockquote>
<ul>
<li><p>第一点，自尊是我们看待自己的方式，我们对自己的想法，以及我们赋予自己的价值。</p>
<ul>
<li>低自尊：意味着你对自我的品质和价值有负面的核心信念。</li>
</ul></li>
<li>第二点，<code>典型</code>的低自尊我们称之为「冒充者综合征」，是一种非常典型的，觉得自己不够好的现象。
<ul>
<li>自恋者则是一种<code>不典型</code>的低自尊，Ta 们通过贬低他人来维护自己脆弱的自我感。</li>
</ul></li>
<li>第三点，自尊由三大组成部分，分别是自爱、自我观、自信。
<ul>
<li>这三个部分会影响到人们的自尊水平，如果发展得不好，则会造成低自尊的形成，其中自爱与否，在很大程度上取决于童年时期是否得到了爱和情感的滋养，有来自家庭也有来自于学校、同伴。</li>
<li>自我观来自于外界对我们的评价，在童年时期这部分更多由家庭、父母带来。</li>
<li>最后，自信是来自于我们关于成功和失败的经验。</li>
</ul></li>
</ul>
<blockquote>
<p>你觉得自己是个怎样的人，你会如何评价你自己呢？用三句话来讲讲吧～</p>
<p>我认为自己的自尊水平是有波动的，有点「冒充者综合征」的感觉，但大部分时间是好的。对于自爱、自我观、自信，我认为我是由足够的自信的，有的时候还是比较自我的，但是不够自爱，可能跟原生家庭有关系，需要自我改善。</p>
</blockquote>
<h2 id="自尊水平2">自尊水平2</h2>
<blockquote>
<p>自尊水平：如何找回自信？</p>
</blockquote>
<ul>
<li>我们可以从情绪（差）、认知（负面）、行为（希望让他人满意）三个方面去察觉自己的自尊水平，这三者之间形成的负面情绪，是低自尊的根本所在。</li>
<li>我们可以通过区分实时和感受、打破负面预期、做出行动实验，来进一步打造自己的坚固自尊水平。</li>
</ul>
<blockquote>
<p>一张表。发现问题并改正它。</p>
</blockquote>
<p><img src="https://user-images.githubusercontent.com/48743005/127887119-849fceb3-d949-42a4-abf0-83a1421012ed.png" /></p>
<h2 id="自我接纳">自我接纳</h2>
<blockquote>
<p>自我接纳：不再苛求自己</p>
</blockquote>
<ul>
<li>总是追求正常会让我们难以接纳正常的自己，这往往是因为害怕被抛弃或者为了实现目标。</li>
<li>自我接纳就是，尽管你与众不同或者有缺陷，但你依然认可你自己。它可以降低我们的痛苦感，让我们过上更自由的生活。</li>
<li><strong>善与自我接纳的人的想法</strong>：我接纳自己的所有情绪，包括不好的情绪；我接受，不代表我放弃改变的可能；如果错了，我要弄明白具体原因；我或许向往完美，但不刻意追求。</li>
<li><strong>自我接纳的四个方法</strong>
<ul>
<li>换一种评估方式</li>
<li>接触更多不同的人</li>
<li>问自己正确的问题、多问描述性的问题</li>
<li>接纳自己不够好的部分：用<code>足够好</code>的标准替代不切实际的<code>完美标准</code></li>
</ul></li>
</ul>
<blockquote>
<p>你最不能够接纳自己哪一点？为什么呢？尝试接纳自己吧。</p>
</blockquote>
<h2 id="自我关怀">自我关怀</h2>
<blockquote>
<p>自我关怀：与自我厌恶说再见</p>
</blockquote>
<ul>
<li>自我关怀，意味着做到宽容自己，接纳自己，理解自己的过失和苦难，并坦然接受人无完人这一事实。</li>
<li>自我关怀的核心组成部分有三点
<ul>
<li>用宽慰自己取代自我批判</li>
<li>认识到痛苦和不完美是人的共性</li>
<li>静观当下</li>
</ul></li>
<li>自我关怀的好处：帮助我们增强情绪修复力，同时提升动机，促进自我成长。</li>
<li>自我关怀不是自怨自艾，不是自我放纵。</li>
<li>培养自我关怀需注意：
<ul>
<li>在对待自己时，想想如何对待他人</li>
<li>注意使用的语言</li>
<li>用肢体动作来安抚自己</li>
<li>准备并记住一些安慰自己的话</li>
</ul></li>
</ul>
<blockquote>
<p>当你想要关怀自己的时候，一般会做什么呢？</p>
<p>打篮球？</p>
</blockquote>
]]></content>
      <categories>
        <category>成长</category>
      </categories>
      <tags>
        <tag>个人成长</tag>
      </tags>
  </entry>
  <entry>
    <title>【前端】GrokLearning-HTML&amp;CSS</title>
    <url>/2021/08/03/%E3%80%90%E5%89%8D%E7%AB%AF%E3%80%91GrokLearning-HTML-CSS/</url>
    <content><![CDATA[<blockquote>
<p>https://groklearning.com/ 学习笔记。</p>
</blockquote>
<span id="more"></span>
<h1 id="什么是-html-和-css">什么是 HTML 和 CSS</h1>
<ul>
<li>Every time you use the web, you're seeing HTML (HyperText Markup Language) and CSS (Cascading Style Sheets).</li>
<li>A webpage is made of two things: <strong>content</strong> and <strong>style</strong>.
<ul>
<li>The <strong>content</strong> is defined by <strong>HTML</strong>, which describes the information in a document and its structure or meaning.</li>
<li>The <strong>style</strong> is defined by <strong>CSS</strong>.</li>
</ul></li>
</ul>
<h2 id="注释方式">注释方式</h2>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--这是 html 的注释方式--&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*这是 css 的注释方式*/</span></span><br></pre></td></tr></table></figure>
<h2 id="content内容">Content（内容）</h2>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Tags
<ul>
<li><code>&lt;h1&gt;...&lt;/h1&gt;</code>, which refers to a heading. (normally 32px - <a href="https://en.wikipedia.org/wiki/Pixel">pixels</a>)</li>
<li><code>&lt;p&gt;...&lt;/p&gt;</code>, which refers to a paragraph.</li>
</ul></li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>This is a level 1 heading.<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>This is a paragraph.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="style风格">Style（风格）</h2>
<h3 id="添加方式">添加方式</h3>
<blockquote>
<p>There are two types of style settings.</p>
</blockquote>
<ul>
<li><strong>Type 1</strong>: You can add a style attribute to the <strong>tag</strong>.</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Heading<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">style</span>=<span class="string">&quot;color: deeppink&quot;</span>&gt;</span>Heading<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>Type 2</strong>: You can add a style attribute <strong>at the beginning</strong>.</li>
</ul>
<blockquote>
<p><strong>Hint: The style elements must be placed at the beginning of the document before anything else (below the <code>&lt;!DOCTYPE html&gt;</code>)</strong>.</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">  <span class="selector-tag">h1</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">color</span>: rebeccapurple;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Heading<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Another Heading<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="一些-style-的属性">一些 Style 的属性</h3>
<ul>
<li>Some style attributes
<ul>
<li><strong>color</strong>（颜色）
<ul>
<li>The full list of supported colour names is defined <a href="https://www.w3.org/TR/css3-color/#svg-color">here</a>.</li>
</ul></li>
<li><strong>font-family</strong>（字体类型）
<ul>
<li>'Times New Roman', Times, serif, Impact, Charcoal, sans-serif and so on.</li>
<li>A typeface or font family defines how each symbol in text looks.</li>
</ul></li>
<li><strong>font-size</strong>（字体大小）
<ul>
<li>The font size for a level 1 heading (<code>h1</code>) is normally <code>32px</code> (where <code>px</code> stands for <a href="https://en.wikipedia.org/wiki/Pixel">pixels</a> – the individuals dot in an image).</li>
</ul></li>
<li><strong>line-height</strong>（行高）
<ul>
<li>The line-height property is specified relative to the font-size, e.g. a line-height of 2 is <span class="math inline">\(\color{red}{\text{double spacing}}\)</span>. (attention!)</li>
</ul></li>
<li><strong>margin-left</strong>, <strong>margin-right</strong>, <strong>margin-top</strong>, <strong>margin-bottom</strong>（页边距）
<ul>
<li>The margin property controls space between elements; you can specify top, right, bottom and left margins.</li>
</ul></li>
<li><strong>width</strong>（宽度）
<ul>
<li>The width property controls how wide an element is, not including the margins.</li>
</ul></li>
<li><strong>background-color</strong>（背景色）
<ul>
<li>The background-color property to show the true width of the paragraph element.</li>
</ul></li>
<li><strong>text-transform</strong>（大小写）
<ul>
<li>lowercase：小写</li>
<li>uppercase：大写</li>
<li>capitalize：首字母大写</li>
</ul></li>
</ul></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">  h1&#123;</span><br><span class="line">    margin-bottom: 30px;</span><br><span class="line">    margin-left: 40px;</span><br><span class="line">    margin-top: 30px;</span><br><span class="line">    font-size: 36px;</span><br><span class="line">    font-family: Verdana, Geneva, sans-serif;</span><br><span class="line">  &#125;</span><br><span class="line">  p&#123;</span><br><span class="line">    width: 680px;</span><br><span class="line">    margin-bottom: 30px;</span><br><span class="line">    margin-left: 40px;</span><br><span class="line">    line-height: 1.8;</span><br><span class="line">    font-size: 18px;</span><br><span class="line">    font-family: Georgia, Times, serif;</span><br><span class="line">  &#125;</span><br><span class="line">  span&#123;</span><br><span class="line">    font-family: &#x27;Courier New&#x27;, monospace;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;h1&gt;Monospaced fonts&lt;/h1&gt;</span><br><span class="line">&lt;p&gt;</span><br><span class="line">In a monospaced font, the letters all occupy the same amount of horizontal space. In variable-width fonts, the size of letters and spacings between them can be different.</span><br><span class="line">&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;</span><br><span class="line">You&#x27;re editing this paragraph in a code editor with a monospace font, but styling it with a variable-width font! As well as making coding easier, monospace fonts are fun because you can create ASCII art with them. Style the following span with a monospace font and see what happens!</span><br><span class="line">&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;span&gt;</span><br><span class="line">  ........_.......______.....______..____</span><br><span class="line">  _.._____........_..............._......&lt;br&gt;</span><br><span class="line">  ......./.\.....&#x27;.____.\...&#x27;.___..||_...</span><br><span class="line">  _||_..._|....../.\............./.|_....&lt;br&gt;</span><br><span class="line">  ....../._.\...|.(___.\_|/..&#x27;...\_|..|.|</span><br><span class="line">  ....|.|......./._.\....._..--.`|.|-&#x27;...&lt;br&gt;</span><br><span class="line">  ...../.___.\..._.____`..|.|.........|.|</span><br><span class="line">  ....|.|....../.___.\...[.`/&#x27;`\]|.|.....&lt;br&gt;</span><br><span class="line">  ..._/./...\.\_|.\____).|\.`.___.&#x27;\._|.|</span><br><span class="line">  _.._|.|_..._/./...\.\_..|.|....|.|,....&lt;br&gt;</span><br><span class="line">  ..|____|.|____|\______.&#x27;.`.____..&#x27;|____</span><br><span class="line">  _||_____|.|____|.|____|[___]...\__/....&lt;br&gt;</span><br><span class="line">&lt;/span&gt;</span><br></pre></td></tr></table></figure>
<h1 id="colours-alignment-links-and-images颜色和对齐方式等">Colours, alignment, links, and images（颜色和对齐方式等）</h1>
<h2 id="emphasis强调">Emphasis（强调）</h2>
<ul>
<li>加粗和斜体</li>
</ul>
<blockquote>
<p>The <code>strong</code> element signals that something is important, and the <code>em</code> element (short for emphasis) signals that the words should be read in a different voice.</p>
</blockquote>
<ul>
<li>例子</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">  This is an <span class="tag">&lt;<span class="name">strong</span>&gt;</span>important<span class="tag">&lt;/<span class="name">strong</span>&gt;</span> sentence,</span><br><span class="line">  with an <span class="tag">&lt;<span class="name">em</span>&gt;</span>interesting ending<span class="tag">&lt;/<span class="name">em</span>&gt;</span>.</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://user-images.githubusercontent.com/48743005/127953010-4263620d-31ce-477c-80cf-4269b7af3953.png" /></p>
<h2 id="break-element断行">Break element（断行）</h2>
<blockquote>
<p>The <code>br</code> element can be used to break up text into new lines without having to separate it into separate paragraphs.</p>
</blockquote>
<ul>
<li><p><code>&lt;br&gt;</code> doesn't need closing!</p></li>
<li><p>例子</p></li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">  First paragraph which is <span class="tag">&lt;<span class="name">br</span>&gt;</span> broken into two lines.</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">  Second paragraph which is not broken at all.</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://user-images.githubusercontent.com/48743005/127953114-edc8aee6-31a1-46dc-a169-292f2af32b0d.png" /></p>
<h2 id="text-alignment对齐方式">Text Alignment（对齐方式）</h2>
<blockquote>
<p>Text alignment determines where text is placed horizontally on a page.</p>
</blockquote>
<ul>
<li>The four main values for text alignment are <code>left</code>, <code>right</code>, <code>center</code> and <code>justify</code>（自适应）.</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css"><span class="selector-tag">h1</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="css">    <span class="attribute">width</span>: <span class="number">600px</span>;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"><span class="selector-tag">p</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">text-align</span>: justify;</span></span><br><span class="line"><span class="css">    <span class="attribute">width</span>: <span class="number">600px</span>;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Centered Heading<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">This text is justified. Text lines up the left and right edges to the left and right content edges of the paragraph. Justified text is often used in newspapers, although studies have shown that text with jagged edges, that is, non-justified text, is easier to read as the eyes can more easily keep track of one&#x27;s progress. </span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://user-images.githubusercontent.com/48743005/127953197-973872f7-f9ca-46a2-8b81-93d44f179044.png" /></p>
<h2 id="span-element单独元素">Span element（单独元素）</h2>
<blockquote>
<p>The <code>span</code> element is designed to group some text within a paragraph to apply a style to it. It doesn't do (or mean) anything on its own.</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">  My favourite colour is <span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&quot;color: red&quot;</span>&gt;</span>red<span class="tag">&lt;/<span class="name">span</span>&gt;</span>.</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">  This <span class="tag">&lt;<span class="name">span</span>&gt;</span>span tag<span class="tag">&lt;/<span class="name">span</span>&gt;</span> has no effect.</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://user-images.githubusercontent.com/48743005/127953281-958ad9b5-f5d5-4975-a9bd-28ad44f977a0.png" /></p>
<h2 id="red-green-blue-rgb颜色属性配置">Red-Green-Blue (RGB)（颜色属性配置）</h2>
<blockquote>
<p>Designing beautiful websites would be difficult if the <a href="https://www.w3.org/TR/css3-color/#svg-color">named CSS colours</a> were the only ones you could use. You can specify your own colours as a mixture of <strong>red</strong>, <strong>green</strong> and <strong>blue</strong> (RGB) light, where each colour is a number between 0 and 255, with 0 being no colour, and 255 being maximum colour.</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&quot;color: rgb(255, 0, 0)&quot;</span>&gt;</span>Red<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&quot;color: rgb(0, 255, 0)&quot;</span>&gt;</span>Green<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&quot;color: rgb(0, 0, 255)&quot;</span>&gt;</span>Blue<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&quot;color: rgb(255, 128, 0)&quot;</span>&gt;</span>Orange<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&quot;color: rgb(128, 20, 180)&quot;</span>&gt;</span>Purple<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://user-images.githubusercontent.com/48743005/127953344-4b2c163d-98f2-4966-b84a-92a15dbf9302.png" /></p>
<h2 id="links超链接">Links（超链接）</h2>
<blockquote>
<p>The <code>anchor</code> element (abbreviated to <code>a</code>) creates links on pages. The address to link to must be added in the href attribute.</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">  Click <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://groklearning.com/about&quot;</span>&gt;</span>here<span class="tag">&lt;/<span class="name">a</span>&gt;</span> to follow the link.</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://user-images.githubusercontent.com/48743005/127953432-c51cc0fc-d16b-41d2-9bc1-89b389fada1f.png" /></p>
<h3 id="text-decoration">Text Decoration</h3>
<ul>
<li>Links are underlined by default, but we can change this for any text with the text-decoration property. The options are <code>overline</code>, <code>line-through</code>, <code>underline</code> and <code>none</code>.（对超链接文本增加属性）</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">  <span class="selector-tag">a</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">text-decoration</span>: none;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://groklearning.com/about/&quot;</span>&gt;</span>About page<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://user-images.githubusercontent.com/48743005/127953632-6441727e-65e5-45f5-999c-ec61341e0bdf.png" /></p>
<h2 id="centring-auto-width-margins又是居中">Centring: Auto-width Margins（又是居中）</h2>
<blockquote>
<p>To centre this element <code>h1</code> on the screen, you should set the left and right margins to auto.</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css"><span class="selector-tag">h1</span> &#123;    </span></span><br><span class="line"><span class="css">    <span class="attribute">width</span>: <span class="number">600px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">margin-left</span>: auto;</span></span><br><span class="line"><span class="css">    <span class="attribute">margin-right</span>: auto; </span></span><br><span class="line"><span class="css">    <span class="attribute">background-color</span>: lightgray;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span></span><br><span class="line">This heading and its grey background show how to centre a specific element, which could be headings or paragraphs.</span><br><span class="line"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://user-images.githubusercontent.com/48743005/127953760-bc858516-d874-4b7b-8298-0702361b28f4.png" /></p>
<h2 id="images插图">Images（插图）</h2>
<h3 id="插图标签">插图标签</h3>
<blockquote>
<p>You need a <code>src</code> attribute (stands for source) which is the filename of the image (like a link).</p>
</blockquote>
<ul>
<li><code>&lt;img&gt;</code> doesn't need closing!</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;cat.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;A picture of a cat&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://user-images.githubusercontent.com/48743005/127953837-d1c60d00-6aab-49bc-b3c5-5e8d6be070ed.png" /></p>
<h3 id="丢失属性">丢失属性</h3>
<blockquote>
<p>You must also include an <code>alt</code> attribute which is the text that should appear if the image is missing.</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;missing.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;This image file is missing.&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://user-images.githubusercontent.com/48743005/127953906-969f77eb-5ea3-4351-8fa7-3dc1be71d8dd.png" /></p>
<h3 id="height-and-width高度和宽度">Height and width（高度和宽度）</h3>
<blockquote>
<p>You can set <code>width</code> and <code>height</code> attributes on your <code>&lt;img&gt;</code> elements to change their size.</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;cat.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;A cat&quot;</span> <span class="attr">width</span>=<span class="string">&quot;100&quot;</span> <span class="attr">height</span>=<span class="string">&quot;300&quot;</span> &gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://user-images.githubusercontent.com/48743005/127954095-1b071cc7-ba4a-49d9-a7de-1429f873fcab.png" /></p>
<h3 id="full-size-images全尺寸">Full size images（全尺寸）</h3>
<blockquote>
<p>As well as changing the size of an image to specific dimensions, you can also set it to <code>a percentage of the width</code> of the page. You can set this on the image tag directly.</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;cat.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;A cat&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width:50%&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://user-images.githubusercontent.com/48743005/127954145-477f92de-d1cc-424d-a41a-239e793e1309.png" /></p>
<h1 id="html-document-structure-and-lists文档结构">HTML document structure and lists（文档结构）</h1>
<h2 id="一般结构">一般结构</h2>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>...<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="separate-stylesheets分离样式">Separate stylesheets（分离样式）</h2>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--test.html--&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;main.css&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Page heading <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*main.css*/</span></span><br><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: deeppink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="lists-of-things编号列表的创建">Lists of things（编号列表的创建）</h2>
<h3 id="unordered-list无序">unordered list（无序）</h3>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>List of fruit:<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Watermelon<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Mango<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Banana<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Strawberry<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://user-images.githubusercontent.com/48743005/128151174-0f230723-5af0-4525-a72d-1dcd8b6d9722.png" /></p>
<h3 id="ordered-list有序">ordered list（有序）</h3>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Homework TODO:<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Read the last act of Hamlet;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Finish trigonometry assignment;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Write business studies report.<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://user-images.githubusercontent.com/48743005/128151430-11188f83-36d7-4503-b1a1-cc5bc42ce729.png" /></p>
<h3 id="列表的属性">列表的属性</h3>
<h4 id="位置">位置</h4>
<ul>
<li>The <code>list-style-position</code> property on <code>ol</code> and <code>ul</code> elements specifies whether the bullet or number is <code>inside</code> or <code>outside</code> the <code>list</code>.</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">style</span>=<span class="string">&quot;text-align: center;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h3</span>&gt;</span>Outside the list<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ol</span> <span class="attr">style</span>=<span class="string">&quot;list-style-position: outside;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>Centred list<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>where list style position<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>is set to outside.<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h3</span>&gt;</span>Inside the list<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ol</span> <span class="attr">style</span>=<span class="string">&quot;list-style-position: inside;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>Centred list<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>where list style position<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>is set to inside.<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://user-images.githubusercontent.com/48743005/128155257-a0426539-3dcf-4209-9751-4f3c5f9d8de0.png" /></p>
<h4 id="格式">格式</h4>
<ul>
<li>列表序号的格式</li>
<li>Another cool list property you can set is the <code>list-style-type</code>, which changes the bullet (for unordered lists) and the number (for ordered lists).</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;main.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Code<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Create<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Compete<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Alpha<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Bravo<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Charlie<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">ul</span> &#123;</span><br><span class="line">  <span class="attribute">list-style-type</span>: square;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">ol</span> &#123;</span><br><span class="line">  <span class="attribute">list-style-type</span>: lower-alpha;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://user-images.githubusercontent.com/48743005/128155541-7735246c-25dc-4a8b-a306-04b5dc75959b.png" /></p>
<h2 id="superscript-and-subscript上下标">Superscript and subscript（上下标）</h2>
<ul>
<li>上标：<code>&lt;sup&gt;...&lt;/sup&gt;</code></li>
<li>下标：<code>&lt;sub&gt;...&lt;/sub&gt;</code></li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>The mass-energy equivalence forumla is E = mc<span class="tag">&lt;<span class="name">sup</span>&gt;</span>2<span class="tag">&lt;/<span class="name">sup</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>The molecular formula for caffeine is C<span class="tag">&lt;<span class="name">sub</span>&gt;</span>8<span class="tag">&lt;/<span class="name">sub</span>&gt;</span>H<span class="tag">&lt;<span class="name">sub</span>&gt;</span>10<span class="tag">&lt;/<span class="name">sub</span>&gt;</span>N<span class="tag">&lt;<span class="name">sub</span>&gt;</span>4<span class="tag">&lt;/<span class="name">sub</span>&gt;</span>O<span class="tag">&lt;<span class="name">sub</span>&gt;</span>2<span class="tag">&lt;/<span class="name">sub</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://user-images.githubusercontent.com/48743005/128153013-c1c8fd45-58a8-4ea5-96ea-e536699405a2.png" /></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>HTML/CSS</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>【分词】日文分词工具-Mecab</title>
    <url>/2021/07/04/%E3%80%90%E5%88%86%E8%AF%8D%E3%80%91%E6%97%A5%E6%96%87%E5%88%86%E8%AF%8D%E5%B7%A5%E5%85%B7-Mecab/</url>
    <content><![CDATA[<blockquote>
<p>主要介绍了日文分词工具 Mecab 的基本使用。</p>
</blockquote>
<span id="more"></span>
<h2 id="安装与配置">安装与配置</h2>
<ul>
<li>下载好 mecab-0.996.exe （<a href="https://taku910.github.io/mecab/#install-windows">for windows</a>）
<ul>
<li>注意安装时编码格式 UTF-8</li>
<li>安装路径默认即可</li>
</ul></li>
<li>安装好 mecab-python：<code>pip install mecab-python3</code> <a href="https://pypi.org/project/mecab-python3/">参考 mecab-python3</a></li>
</ul>
<h2 id="测试">测试</h2>
<h3 id="词性标注">词性标注</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> MeCab</span><br><span class="line">mecab = MeCab.Tagger (<span class="string">&quot;-Ochasen&quot;</span>)</span><br><span class="line">sentence = <span class="string">&#x27;太郎はこの本を二郎を見た女性に渡した。&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(mecab.parse(sentence))</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">太郎	タロウ	太郎	名詞-固有名詞-人名-名		</span><br><span class="line">は	ハ	は	助詞-係助詞		</span><br><span class="line">この	コノ	この	連体詞		</span><br><span class="line">本	ホン	本	名詞-一般		</span><br><span class="line">を	ヲ	を	助詞-格助詞-一般		</span><br><span class="line">二	ニ	二	名詞-数		</span><br><span class="line">郎	ロウ	郎	名詞-一般		</span><br><span class="line">を	ヲ	を	助詞-格助詞-一般		</span><br><span class="line">見	ミ	見る	動詞-自立	一段	連用形</span><br><span class="line">た	タ	た	助動詞	特殊・タ	基本形</span><br><span class="line">女性	ジョセイ	女性	名詞-一般		</span><br><span class="line">に	ニ	に	助詞-格助詞-一般		</span><br><span class="line">渡し	ワタシ	渡す	動詞-自立	五段・サ行	連用形</span><br><span class="line">た	タ	た	助動詞	特殊・タ	基本形</span><br><span class="line">。	。	。	記号-句点		</span><br><span class="line">EOS</span><br></pre></td></tr></table></figure>
<h3 id="分词">分词</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> MeCab</span><br><span class="line">mecab = MeCab.Tagger (<span class="string">&quot;-Owakati&quot;</span>)</span><br><span class="line">sentence = <span class="string">&#x27;太郎はこの本を二郎を見た女性に渡した。&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(mecab.parse(sentence))</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">太郎 は この 本 を 二 郎 を 見 た 女性 に 渡し た 。 </span><br></pre></td></tr></table></figure>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://www.52nlp.cn/%E6%97%A5%E6%96%87%E5%88%86%E8%AF%8D%E5%99%A8-mecab-%E6%96%87%E6%A1%A3">日文分词器 Mecab 文档</a></li>
<li><a href="https://taku910.github.io/mecab/#install-windows">MeCab: Yet Another Part-of-Speech and Morphological Analyzer</a></li>
</ul>
]]></content>
      <categories>
        <category>NLP 工具</category>
      </categories>
      <tags>
        <tag>Mecab</tag>
      </tags>
  </entry>
  <entry>
    <title>【实用工具】Docker</title>
    <url>/2021/08/03/%E3%80%90%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E3%80%91Docker/</url>
    <content><![CDATA[<blockquote>
<p>实用工具 Docker 的实操记录。</p>
</blockquote>
<span id="more"></span>
<h1 id="安装与使用">安装与使用</h1>
<h2 id="docker-的作用">Docker 的作用</h2>
<ul>
<li>使得不同依赖包之间互不影响，具有 <strong>隔离性</strong> 的特点（类似于虚拟环境的作用用于隔离）；</li>
<li>Docker 配置文件，一键部署，具有 <strong>快速部署</strong> 的特点。</li>
</ul>
<h2 id="docker-的安装">Docker 的安装</h2>
<ul>
<li><a href="https://www.docker.com/products/docker-desktop">下载地址</a>
<ul>
<li>可能需要注册账号</li>
<li>一键安装即可（Windows）</li>
</ul></li>
</ul>
<h2 id="三个基本概念">三个基本概念</h2>
<ul>
<li>Image 镜像，Container 容器，Repository 仓库。</li>
<li><strong>仓库</strong>：下载软件的商店（free）；</li>
<li><strong>镜像</strong>：下载好的可安装的文件；</li>
<li><strong>容器</strong>：已经安装好的应用程序。</li>
</ul>
<h2 id="一般使用操作">一般使用操作</h2>
<h3 id="登入操作">登入操作</h3>
<ul>
<li><code>docker login</code></li>
</ul>
<h3 id="进入容器不影响其它窗口">进入容器（不影响其它窗口）</h3>
<ul>
<li><code>docker ps -a</code> # 打印容器</li>
<li><code>docker exec -it container_id /bin/bash</code> # 进入某个 id 容器</li>
</ul>
<h1 id="参考">参考</h1>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/49492290">由浅入深 docker 系列：（1）安装使用</a></li>
<li><a href="https://www.cnblogs.com/xhyan/p/6593075.html">Docker容器进入的4种方式</a></li>
</ul>
]]></content>
      <categories>
        <category>实用工具-Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>实用工具</tag>
      </tags>
  </entry>
  <entry>
    <title>【实用工具】Tmux</title>
    <url>/2021/07/07/%E3%80%90%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E3%80%91Tmux/</url>
    <content><![CDATA[<blockquote>
<p>本文主要介绍了终端连接软件 Tmux 的基本操作。</p>
</blockquote>
<span id="more"></span>
<h2 id="主要构件">主要构件</h2>
<ul>
<li>session（会话）：一种服务，可以创建，可以查看</li>
<li>window（窗口）：一个会话，可以包含多个窗口</li>
<li>pane（窗格）：一个窗口，可以包含多个窗格</li>
</ul>
<h2 id="session会话">session（会话）</h2>
<ul>
<li>终端<strong>新建</strong>会话 - <code>tmux new -s session1</code></li>
<li>终端<strong>进入</strong>会话 - <code>tmux a -t session1</code></li>
<li><strong>查看</strong>会话
<ul>
<li>终端环境 - <code>tmux ls</code></li>
<li>会话环境 - <code>ctrl+b - s</code> - (detached)</li>
</ul></li>
<li><strong>退出</strong>会话到终端 - <code>ctrl+b - d</code></li>
<li><strong>销毁</strong>会话 - <code>tmux kill-session -t session1</code></li>
<li><strong>重命名</strong>会话
<ul>
<li>终端环境 - <code>tmux rename -t old_name new_name</code></li>
<li>会话环境 - <code>ctrl+b - $</code></li>
</ul></li>
</ul>
<h2 id="window窗口">window（窗口）</h2>
<ul>
<li><strong>创建</strong>窗口 - <code>ctrl+b - c</code></li>
<li><strong>切换</strong>窗口
<ul>
<li>列出所有窗口，上下键切换 - <code>ctrl+b - w</code></li>
<li>上一个 - <code>ctrl+b - p</code></li>
<li>下一个 - <code>ctrl+b - n</code></li>
<li>第 <span class="math inline">\(i\)</span> 个 - <code>ctrl+b - number</code></li>
<li>相邻窗口切换 - <code>ctrl+b - l</code></li>
</ul></li>
<li><strong>关闭</strong>窗口（当前）</li>
<li><strong>重命名</strong>当前窗口 - <code>ctrl+b - ,</code></li>
</ul>
<h2 id="pane窗格">pane（窗格）</h2>
<ul>
<li><strong>垂直</strong>分屏 - <code>ctrl+b - %</code></li>
<li><strong>水平</strong>分屏 - <code>ctrl+b - &quot;</code></li>
<li><strong>切换</strong>窗格
<ul>
<li>依次切换 - <code>ctrl+b - o</code></li>
<li>按方向键 - <code>ctrl+b - 键盘上下左右</code></li>
<li>对当前窗格重新排列 - <code>ctrl+b - space</code></li>
<li>最大化当前的窗格 - <code>ctrl+b - z</code></li>
</ul></li>
<li><strong>关闭</strong>当前窗格 - <code>ctrl+b - x</code></li>
</ul>
]]></content>
      <categories>
        <category>实用工具-Tmux</category>
      </categories>
      <tags>
        <tag>实用工具</tag>
      </tags>
  </entry>
  <entry>
    <title>【实用工具】npm和yarn包管理</title>
    <url>/2021/08/30/%E3%80%90%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E3%80%91npm%E5%92%8Cyarn%E5%8C%85%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<blockquote>
<p>包管理器是一段代码，它可以让你管理依赖（你或者他人写的外部代码），项目需要这些依赖来正确运行。</p>
</blockquote>
<span id="more"></span>
<ul>
<li>等待整理。</li>
</ul>
<h1 id="参考">参考</h1>
<ul>
<li><a href="https://segmentfault.com/a/1190000017075256">package-lock.json和yarn.lock的包依赖区别</a></li>
<li><a href="https://www.cnblogs.com/tu-0718/p/12571143.html">yarn的安装和常用命令</a></li>
<li><a href="https://www.cnblogs.com/cisum/p/8401271.html">yarn之安装依赖包</a></li>
</ul>
]]></content>
      <categories>
        <category>实用工具</category>
      </categories>
      <tags>
        <tag>yarn</tag>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title>【常用命令】pip与conda</title>
    <url>/2021/07/19/%E3%80%90%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E3%80%91pip%E4%B8%8Econda/</url>
    <content><![CDATA[<blockquote>
<p>介绍 pip 与 conda 的常用命令。</p>
</blockquote>
<span id="more"></span>
<blockquote>
<p>科普 <a href="https://www.cnblogs.com/piperck/p/5057291.html">pip与conda的区别1</a> <a href="https://blog.csdn.net/taopanpantao/article/details/53982752">pip与conda的区别2</a></p>
</blockquote>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">作用</th>
<th style="text-align: left;">pip基本命令</th>
<th style="text-align: left;">conda基本命令</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">查看版本</td>
<td style="text-align: left;"><code>pip --version</code></td>
<td style="text-align: left;"><code>conda --version</code></td>
</tr>
<tr class="even">
<td style="text-align: left;">升级版本</td>
<td style="text-align: left;"><code>pip install -U pip</code></td>
<td style="text-align: left;"><code>conda update conda</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;">列出所有安装包</td>
<td style="text-align: left;"><code>pip list</code></td>
<td style="text-align: left;"><code>conda list</code></td>
</tr>
<tr class="even">
<td style="text-align: left;">检测更新</td>
<td style="text-align: left;"><code>pip list –outdated</code></td>
<td style="text-align: left;"><code>N</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;">更新某个库</td>
<td style="text-align: left;"><code>pip install --upgrade #库名字</code></td>
<td style="text-align: left;"><code>conda update #库名字</code></td>
</tr>
<tr class="even">
<td style="text-align: left;">安装(更新)某个库为指定版本</td>
<td style="text-align: left;"><code>pip install &quot;#库名字==版本号&quot;</code></td>
<td style="text-align: left;"><code>conda install #库名字=版本号</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;">更新所有库</td>
<td style="text-align: left;"><code>N</code></td>
<td style="text-align: left;"><code>conda update --all</code></td>
</tr>
<tr class="even">
<td style="text-align: left;">卸载库</td>
<td style="text-align: left;"><code>pip uninstall #库名字</code></td>
<td style="text-align: left;"><code>conda uninstall #库名字</code></td>
</tr>
</tbody>
</table>
<ul>
<li><code>conda</code> 创建，查看，激活，删除虚拟环境
<ul>
<li>创建：<code>conda create -n your_env_name python=X.X</code></li>
<li>查看：<code>conda env list</code></li>
<li>激活：<code>conda(source) activate your_env_name</code>
<ul>
<li>关闭：<code>(source) deactivate</code></li>
</ul></li>
<li>删除：<code>conda remove -n your_env_name --all</code>
<ul>
<li>删除环境某个包：<code>conda remove --name your_env_name package_name</code></li>
</ul></li>
</ul></li>
<li><code>conda</code> 更改环境名
<ul>
<li><code>先 clone 一份 new name 的环境</code></li>
<li><code>删除 old name 的环境</code></li>
</ul></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 第一步</span></span><br><span class="line">conda create -n new_name --clone old_name</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 第二步</span></span><br><span class="line">conda remove -n old_name --all</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>常用命令</category>
      </categories>
      <tags>
        <tag>常用命令</tag>
      </tags>
  </entry>
  <entry>
    <title>【技术问题】JupyterNotebook 切换环境</title>
    <url>/2021/07/05/%E3%80%90%E6%8A%80%E6%9C%AF%E9%97%AE%E9%A2%98%E3%80%91JupyterNotebook-%E5%88%87%E6%8D%A2%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<blockquote>
<p>关于 Jupyter Notebook 设置支持切换虚拟运行环境的步骤。</p>
</blockquote>
<span id="more"></span>
<h2 id="创建可切换环境">创建可切换环境</h2>
<blockquote>
<p>为了让 Jupyter Notebook 支持切换虚拟运行环境。</p>
</blockquote>
<ul>
<li>首先，在命令窗口中 activate 你创造的那个新环境。</li>
<li>然后，安装 ipykernel。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ conda install ipykernel</span><br></pre></td></tr></table></figure>
<ul>
<li>安装完后，重启jupyter notebook就可以看见kernel的选项了。</li>
</ul>
<h2 id="删除可切换环境">删除可切换环境</h2>
<ul>
<li><p>查看 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ jupyter kernelspec list</span><br></pre></td></tr></table></figure></p></li>
<li><p>删除 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ jupyter kernelspec remove kernel_name</span><br></pre></td></tr></table></figure></p></li>
</ul>
<h2 id="如果没反应">如果没反应</h2>
<ul>
<li>进入环境修改（我的环境名是 IRpyterrier）</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python -m ipykernel install --user --name IRpyterrier --display-name <span class="string">&quot;Python (IRpyterrier)&quot;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术问题</category>
      </categories>
      <tags>
        <tag>技术问题</tag>
      </tags>
  </entry>
  <entry>
    <title>【技术问题】VSCode 连不上某一个服务器</title>
    <url>/2021/07/05/%E3%80%90%E6%8A%80%E6%9C%AF%E9%97%AE%E9%A2%98%E3%80%91VSCode-%E8%BF%9E%E4%B8%8D%E4%B8%8A%E6%9F%90%E4%B8%80%E4%B8%AA%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<blockquote>
<p>关于 remote-SSH 连不上某一个服务器的解决方法。</p>
</blockquote>
<span id="more"></span>
<h2 id="问题描述">问题描述</h2>
<blockquote>
<p>打开 VSCode，remote-SSH 连不上某一个服务器。</p>
</blockquote>
<h2 id="解决方案">解决方案</h2>
<ul>
<li>打开该服务器终端，删除配置即可。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ rm -rf .vscode-server/</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术问题</category>
      </categories>
      <tags>
        <tag>技术问题</tag>
      </tags>
  </entry>
  <entry>
    <title>【技术问题】修改Ubuntu用户名</title>
    <url>/2021/08/04/%E3%80%90%E6%8A%80%E6%9C%AF%E9%97%AE%E9%A2%98%E3%80%91%E4%BF%AE%E6%94%B9Ubuntu%E7%94%A8%E6%88%B7%E5%90%8D/</url>
    <content><![CDATA[<blockquote>
<p>Ubuntu 下修改用户名的具体操作。</p>
</blockquote>
<span id="more"></span>
<blockquote>
<p>参考：https://www.jianshu.com/p/170521ab7403</p>
</blockquote>
<h1 id="切换到-root-用户">切换到 root 用户</h1>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 如果设置了密码可跳过此步</span></span><br><span class="line">ubuntu@VM-0-4-ubuntu:~$ sudo passwd root</span><br><span class="line"><span class="meta">#</span><span class="bash"> 为用户修改密码也可以使用此命令</span></span><br><span class="line"></span><br><span class="line">ubuntu@VM-0-4-ubuntu:~$ su root</span><br><span class="line">Password:</span><br><span class="line">root@VM-0-4-ubuntu:/home/ubuntu#</span><br></pre></td></tr></table></figure>
<h1 id="修改用户名">修改用户名</h1>
<h2 id="a---修改etcpasswd文件-vim-etcpasswd">A - 修改/etc/passwd文件: vim /etc/passwd</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ubuntu:x:500:500::/home/ubuntu:/bin/bash</span><br><span class="line"><span class="meta">#</span><span class="bash"> 把用户名ubuntu改成：你想要的用户名，其他都不要修改</span></span><br><span class="line">test:x:500:500::/home/test:/bin/bash</span><br><span class="line"><span class="meta">#</span><span class="bash"> 打开文件后回发现很多内容，可以利用替换指令进行修改</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> :1,<span class="variable">$s</span>/ubuntu/<span class="built_in">test</span>/g</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 解释: 替换第 1 行开始到最后一行中每一行所有 ubuntu 为 <span class="built_in">test</span></span></span><br></pre></td></tr></table></figure>
<h2 id="b---修改etcshadow文件-vim-etcshadow">B - 修改/etc/shadow文件: vim /etc/shadow</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ubunt:$6$ULolz...EMVYj/:18222:0:99999:7:::</span><br><span class="line"><span class="meta">#</span><span class="bash"> 把用户名ubuntu改成：你想要的用户名，其他都不要修改</span></span><br><span class="line">test:$6$ULolz...EMVYj/:18222:0:99999:7:::</span><br></pre></td></tr></table></figure>
<h2 id="c---修改etcgroup文件-vim-etcgroup">C - 修改/etc/group文件: vim /etc/group</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ubunt:x:1:root,bin,ubuntu</span><br><span class="line"><span class="meta">#</span><span class="bash">...</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 这个文件中的原用户名有很多，可以使用第一步中提到的替换指令修改:</span></span><br><span class="line">:1,$s/ubuntu/test/g</span><br></pre></td></tr></table></figure>
<h2 id="d---修改用户目录">D - 修改用户目录</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mv /home/ubuntu /home/test</span><br></pre></td></tr></table></figure>
<h1 id="切换到新用户名">切换到新用户名</h1>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@VM-0-4-ubuntu:~$ su test</span><br><span class="line">test@VM-0-4-ubuntu:~$</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术问题</category>
      </categories>
      <tags>
        <tag>技术问题</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>【技术问题】登入不了谷歌学术？</title>
    <url>/2021/08/04/%E3%80%90%E6%8A%80%E6%9C%AF%E9%97%AE%E9%A2%98%E3%80%91%E7%99%BB%E5%85%A5%E4%B8%8D%E4%BA%86%E8%B0%B7%E6%AD%8C%E5%AD%A6%E6%9C%AF%EF%BC%9F/</url>
    <content><![CDATA[<blockquote>
<p>如何解决登入不了谷歌学术的问题？</p>
</blockquote>
<span id="more"></span>
<h1 id="step-1极简插件">Step 1:【极简插件】</h1>
<ul>
<li><a href="https://chrome.zzzmh.cn/index#index" class="uri">https://chrome.zzzmh.cn/index#index</a></li>
<li>下载【谷歌上网助手 Ghelper Beta】</li>
</ul>
<h1 id="step-1极简插件-1">Step 1:【极简插件】</h1>
<ul>
<li>在地址栏输入chrome://extensions/打开【开发者模式】的开关；</li>
<li>拖动下载好的插件安装包文件【xxx.crx】到chrome扩展中心即可；</li>
<li>弹出安装确认的提示框，说明操作成功，点击确定即可。</li>
</ul>
]]></content>
      <categories>
        <category>技术问题</category>
      </categories>
      <tags>
        <tag>技术问题</tag>
      </tags>
  </entry>
  <entry>
    <title>【数据分析】SPSS 工具</title>
    <url>/2021/07/05/%E3%80%90%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E3%80%91SPSS-%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<blockquote>
<p>记录 SPSS 工具的一些使用链接。</p>
</blockquote>
<span id="more"></span>
<ul>
<li><p><a href="https://www.zhihu.com/question/20949854">【数据标准化预处理】</a></p></li>
<li>[【二项 Logistic 回归分析】]
<ul>
<li><a href="https://www.zhihu.com/question/34502688" class="uri">https://www.zhihu.com/question/34502688</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/34263213">【二分类logistic回归，更新几个常见问题的解决方法】</a></li>
</ul></li>
<li><a href="https://panzhong171.blog.csdn.net/article/details/80980790">【因子分析】</a>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/145564952">【SPSS因子分析模型实操】</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/31291210">【SPSS 因子分析参数说明】</a></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>数据分析</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>SPSS</tag>
      </tags>
  </entry>
  <entry>
    <title>【数据结构与算法】二进制字符串的划分</title>
    <url>/2021/07/05/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%91%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%88%92%E5%88%86/</url>
    <content><![CDATA[<h1 id="问题说明">问题说明</h1>
<blockquote>
<p>给定一个长度为 <span class="math inline">\(n\)</span> 的二进制字符串。</p>
<p>判断是否可以将字符串分割为 <span class="math inline">\(i\)</span> 个部分，其中 <span class="math inline">\(i \in \left\{0,2,\cdots,n \right\}\)</span>，使得每个部分的十进制为 <span class="math inline">\(7\)</span> 的整数次幂。返回最小的分割的部分的数目。</p>
</blockquote>
<span id="more"></span>
<ul>
<li>If <span class="math inline">\(x= 111110001\)</span>, then the following partition gives powers of <span class="math inline">\(7\)</span>: <span class="math inline">\(111 \mid 110001\)</span>. (<span class="math inline">\(111_2 = 7, 110001_2 = 49\)</span>). In this case, the answer is <span class="math inline">\(2\)</span> and this is the best way to divide <span class="math inline">\(x\)</span> into powers of <span class="math inline">\(7\)</span>.</li>
<li>If <span class="math inline">\(x=11111\)</span>, then it is possible to divide <span class="math inline">\(x\)</span> such that every part is a power of <span class="math inline">\(7\)</span> as follows <span class="math inline">\(1\mid 1 \mid 1 1 1\)</span>. Hence, in this case, the answer is <span class="math inline">\(3\)</span>.</li>
<li>If <span class="math inline">\(x=011111\)</span>, then it is not possible to divide <span class="math inline">\(x\)</span> such that every part is a power of <span class="math inline">\(7\)</span>. Hence, in this case, the answer is <span class="math inline">\(-1\)</span>. (Recall, leading zeros are not allowed.)</li>
<li>If <span class="math inline">\(x=111111\)</span>, then it is possible to divide <span class="math inline">\(x\)</span> such that every part is a power of <span class="math inline">\(7\)</span> in two ways. <span class="math inline">\(1\mid 1 \mid 1\mid 1\mid 1\mid 1\)</span> has <span class="math inline">\(6\)</span> parts and <span class="math inline">\(111\mid 111\)</span> has <span class="math inline">\(2\)</span> parts. Hence, in this case, the answer is <span class="math inline">\(2\)</span>.</li>
</ul>
<blockquote>
<p>For simplicity, leading zeros are <strong>not</strong> allowed in our definition of the powers of <span class="math inline">\(7\)</span>. <span class="math inline">\(111\)</span> is a power of <span class="math inline">\(7\)</span> but <span class="math inline">\(0111\)</span> is not a power of <span class="math inline">\(7\)</span>.</p>
</blockquote>
<h2 id="代码部分">代码部分</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="comment"># global</span></span><br><span class="line">bestSplitNum = sys.maxsize <span class="comment"># Assumed minimum number of divisions</span></span><br><span class="line">powers = <span class="built_in">list</span>() <span class="comment"># store all the powers</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">split</span>(<span class="params">strTemp, start, depth</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    use bfs method to find the shortest path</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">global</span> bestSplitNum</span><br><span class="line">    <span class="keyword">global</span> powers</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> depth &gt;= bestSplitNum:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> start == <span class="built_in">len</span>(strTemp):</span><br><span class="line">        bestSplitNum = depth</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> power <span class="keyword">in</span> powers:</span><br><span class="line">        <span class="comment"># print(power)</span></span><br><span class="line">        <span class="keyword">if</span> strTemp.startswith(power, start):</span><br><span class="line">            split(strTemp, start + <span class="built_in">len</span>(power), depth + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calNumSplit</span>(<span class="params">strTemp</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    the smallest positive integer</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">global</span> bestSplitNum</span><br><span class="line">    <span class="keyword">global</span> powers</span><br><span class="line"></span><br><span class="line">    <span class="comment"># calc all powers of 7 that fits in given string</span></span><br><span class="line">    <span class="built_in">pow</span> = <span class="number">1</span></span><br><span class="line">    powers.append(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">pow</span>:</span><br><span class="line">        binaryPowStr = <span class="built_in">str</span>(<span class="built_in">bin</span>(<span class="built_in">int</span>(math.<span class="built_in">pow</span>(<span class="number">7</span>,<span class="built_in">pow</span>))))[<span class="number">2</span>:] <span class="comment"># get the binary string</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">len</span>(binaryPowStr) &lt;= <span class="built_in">len</span>(strTemp)):</span><br><span class="line">            powers.append(binaryPowStr)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="built_in">pow</span> += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    powers.sort(reverse=<span class="literal">False</span>) <span class="comment"># Sort binary strings in descending order</span></span><br><span class="line">    <span class="comment"># print(powers)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># do recursive split</span></span><br><span class="line">    split(strTemp, <span class="number">0</span>, -<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> bestSplitNum == sys.maxsize:</span><br><span class="line">        <span class="built_in">print</span>(-<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(bestSplitNum + <span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reset</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    reset the global variable</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">global</span> bestSplitNum</span><br><span class="line">    <span class="keyword">global</span> powers</span><br><span class="line">    bestSplitNum = sys.maxsize <span class="comment"># Assumed minimum number of divisions</span></span><br><span class="line">    powers = <span class="built_in">list</span>() <span class="comment"># store all the powers</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line"></span><br><span class="line">    strTest1 = <span class="string">&quot;111110001&quot;</span></span><br><span class="line">    strTest2 = <span class="string">&quot;11111&quot;</span></span><br><span class="line">    strTest3 = <span class="string">&quot;011111&quot;</span></span><br><span class="line">    strTest4 = <span class="string">&quot;111111&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;If the string is &#x27;111110001&#x27;, the answer is: &quot;</span>, sep=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    calNumSplit(strTest1) <span class="comment"># 2</span></span><br><span class="line">    reset()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;If the string is &#x27;11111&#x27;, the answer is: &quot;</span>, sep=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    calNumSplit(strTest2) <span class="comment"># 3</span></span><br><span class="line">    reset()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;If the string is &#x27;011111&#x27;, the answer is: &quot;</span>, sep=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    calNumSplit(strTest3) <span class="comment"># -1</span></span><br><span class="line">    reset()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;If the string is &#x27;111111&#x27;, the answer is: &quot;</span>, sep=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    calNumSplit(strTest4) <span class="comment"># 2</span></span><br><span class="line">    reset()</span><br></pre></td></tr></table></figure>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://www.coder.work/article/1919524">algorithm - 检查二进制字符串是否可以分区，使得每个分区的乘方为5</a></li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>【文件处理】文件（夹）的一些常用处理总结</title>
    <url>/2021/07/18/%E3%80%90%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86%E3%80%91%E6%96%87%E4%BB%B6%EF%BC%88%E5%A4%B9%EF%BC%89%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E5%A4%84%E7%90%86%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<blockquote>
<p>文件（夹）的一些常用处理总结。</p>
</blockquote>
<span id="more"></span>
<h1 id="文件的一般读入写入总结">文件的一般读入写入总结</h1>
<ul>
<li><code>with open</code> 比 <code>open</code> 多一个 自动 <code>close</code> 操作。</li>
</ul>
<h2 id="基本操作">基本操作</h2>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">函数名</th>
<th style="text-align: left;">操作</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">.read()</td>
<td style="text-align: left;">读取文件所有内容</td>
</tr>
<tr class="even">
<td style="text-align: left;">.readlines()</td>
<td style="text-align: left;">将每行文件内容存入列表读取</td>
</tr>
<tr class="odd">
<td style="text-align: left;">.write()</td>
<td style="text-align: left;">写入文件</td>
</tr>
</tbody>
</table>
<h2 id="参数的问题">参数的问题</h2>
<ul>
<li><a href="https://mkyong.com/python/python-difference-between-r-w-and-a-in-open/">reference</a></li>
</ul>
<table>
<thead>
<tr class="header">
<th style="text-align: left;"></th>
<th style="text-align: left;"><code>r</code></th>
<th style="text-align: left;"><code>r+</code></th>
<th style="text-align: left;"><code>w</code></th>
<th style="text-align: left;"><code>w+</code></th>
<th style="text-align: left;"><code>a</code></th>
<th style="text-align: left;"><code>a+</code></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">read</td>
<td style="text-align: left;">O</td>
<td style="text-align: left;">O</td>
<td style="text-align: left;"></td>
<td style="text-align: left;">O</td>
<td style="text-align: left;"></td>
<td style="text-align: left;">O</td>
</tr>
<tr class="even">
<td style="text-align: left;">write</td>
<td style="text-align: left;"></td>
<td style="text-align: left;">O</td>
<td style="text-align: left;">O</td>
<td style="text-align: left;">O</td>
<td style="text-align: left;">O</td>
<td style="text-align: left;">O</td>
</tr>
<tr class="odd">
<td style="text-align: left;">create</td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">O</td>
<td style="text-align: left;">O</td>
<td style="text-align: left;">O</td>
<td style="text-align: left;">O</td>
</tr>
<tr class="even">
<td style="text-align: left;">truncate</td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">O</td>
<td style="text-align: left;">O</td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">position at start</td>
<td style="text-align: left;">O</td>
<td style="text-align: left;">O</td>
<td style="text-align: left;">O</td>
<td style="text-align: left;">O</td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">position at end</td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">O</td>
<td style="text-align: left;">O</td>
</tr>
</tbody>
</table>
<ul>
<li><p><em>truncate</em> means <code>delete the content of the file</code>.</p></li>
<li>Some differences
<ul>
<li>The <code>r</code> throws an error <code>if the file does not exist</code> or opens an existing file <code>without truncating</code> it for <code>reading</code>; the file pointer position <code>at the beginning of the file</code>.</li>
<li>The <code>r+</code> throws an error <code>if the file does not exist</code> or opens an existing file <code>without truncating</code> it for <code>reading and writing</code>; the file pointer position <code>at the beginning of the file</code>.</li>
<li>The <code>w</code> <code>creates a new file</code> or <code>truncates an existing file</code>, then opens it for <code>writing</code>; the file pointer position <code>at the beginning of the file</code>.</li>
<li>The <code>w+</code> <code>creates a new file</code> or <code>truncates an existing file</code>, then opens it for <code>reading and writing</code>; the file pointer position <code>at the beginning of the file</code>.</li>
<li>The <code>a</code> <code>creates a new file</code> or <code>opens an existing file</code> for <code>writing</code>; the file pointer position <code>at the end of the file</code>.</li>
<li>The <code>a+</code> <code>creates a new file</code> or <code>opens an existing file</code> for <code>reading and writing</code>, and the file pointer position <code>at the end of the file</code>.</li>
</ul></li>
</ul>
<h1 id="文件夹不存在则创建">文件（夹）不存在，则创建</h1>
<ul>
<li>文件夹不存在，则创建的问题。</li>
<li>文件（如<code>test.txt</code>）不存在，创建（写入）的问题。</li>
<li>文件夹及文件都不存在，创建（写入）的问题。
<ul>
<li>先创建文件夹，再创建（写入）文件。</li>
</ul></li>
</ul>
<h2 id="若文件夹不存在则创建">若文件夹不存在，则创建</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">if_folder_exists</span>(<span class="params">folder_path</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(folder_path):</span><br><span class="line">        os.makedirs(folder_path)</span><br></pre></td></tr></table></figure>
<h2 id="若文件不存在则创建写入">若文件不存在，则创建（写入）</h2>
<ul>
<li>参考上文-参数的问题-<code>w</code>或者<code>w+</code></li>
</ul>
<h1 id="分离路径和文件名-以及-分离文件名和后缀">分离路径和文件名 以及 分离文件名和后缀</h1>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"> </span><br><span class="line">file_path = <span class="string">&quot;D:/pzlu/test.py&quot;</span></span><br><span class="line">(filepath, tempfilename) = os.path.split(file_path) <span class="comment"># 分离路径和文件名</span></span><br><span class="line">(filename, extension) = os.path.splitext(tempfilename) <span class="comment"># 分离文件名和后缀</span></span><br></pre></td></tr></table></figure>
<h1 id="遍历文件夹下所有文件及目录">遍历文件夹下所有文件及目录</h1>
<h2 id="显示目录下所有文件">显示目录下所有文件</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os </span><br><span class="line"></span><br><span class="line">g = os.walk(<span class="string">r&quot;e:\test&quot;</span>)  </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> path,dir_list,file_list <span class="keyword">in</span> g:</span><br><span class="line">    <span class="comment"># 文件夹路径, 文件夹名字, 文件名</span></span><br><span class="line">    <span class="keyword">for</span> file_name <span class="keyword">in</span> file_list:  </span><br><span class="line">        <span class="built_in">print</span>(os.path.join(path, file_name) )</span><br></pre></td></tr></table></figure>
<h2 id="显示所有子目录">显示所有子目录</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os </span><br><span class="line"></span><br><span class="line">g = os.walk(<span class="string">&quot;e:\test&quot;</span>)  </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> path,dir_list,file_list <span class="keyword">in</span> g:  </span><br><span class="line">    <span class="keyword">for</span> dir_name <span class="keyword">in</span> dir_list:</span><br><span class="line">        <span class="built_in">print</span>(os.path.join(path, dir_name) )</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>文件处理</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>文件处理</tag>
      </tags>
  </entry>
  <entry>
    <title>【文学】《被讨厌的勇气》书评</title>
    <url>/2021/08/03/%E3%80%90%E6%96%87%E5%AD%A6%E3%80%91%E3%80%8A%E8%A2%AB%E8%AE%A8%E5%8E%8C%E7%9A%84%E5%8B%87%E6%B0%94%E3%80%8B%E4%B9%A6%E8%AF%84/</url>
    <content><![CDATA[<blockquote>
<p>原书作者: 岸见一郎 / 古贺史健。</p>
<p>这本书以青年人和智者对话的方式，向读者揭示了种种智慧。</p>
</blockquote>
<span id="more"></span>
<h1 id="生活的枷锁来源于我们对生活的诠释">生活的枷锁来源于我们对生活的诠释</h1>
<p>阿德勒的心理学是要理解人性的真理和目标，这是我们一直都应该探究的问题。我们每个人生活中的不幸究竟是“因果论”，还是“目的论”，这取决于我们的认知。在本文的对话中，我窥见的是另一层面的认知——人能改变，获得幸福很容易。很喜欢这句话：<strong>“决定我们自身的不是过去的经历，而是我们自己赋予经历的意义。”</strong> 生活，充满着很多美好，同时也有很多艰辛与磨难，很多时候我们为了图简单方便，安于现状，不懂得改变，认为生活本应如此，这种观念随着时间的流逝很容易植入内心。很多研究都表明人的不改变（性格）很大程度来源于儿童时期的遭遇，这是能够<strong>理解</strong>的，但能否能改变，却取决于当下，取决于我们的内心。<strong>“无论之前的人生发生过什么，都对今后的人生如何度过没有影响。”决定自己人生的是活在“此时此刻”的你自己。</strong></p>
]]></content>
      <categories>
        <category>文学</category>
      </categories>
      <tags>
        <tag>文学</tag>
        <tag>哲学</tag>
      </tags>
  </entry>
  <entry>
    <title>【文学】《如何阅读一本书》读后感</title>
    <url>/2021/07/16/%E3%80%90%E6%96%87%E5%AD%A6%E3%80%91%E3%80%8A%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6%E3%80%8B%E4%B9%A6%E8%AF%84/</url>
    <content><![CDATA[<blockquote>
<p>《如何阅读一本书》读后感。</p>
<blockquote>
<p>作者：莫提默 · J. 艾德勒 - 查尔斯 · 范多伦</p>
</blockquote>
</blockquote>
<span id="more"></span>
<h1 id="第一篇-阅读的层次">第一篇 阅读的层次</h1>
<h2 id="第一章-阅读的活力与艺术">第一章 阅读的活力与艺术</h2>
<p>思考这样一个问题，我们是否在阅读完一本书后，会有这样的感想：</p>
<ul>
<li>读这本书花了我太久的时间，或是花了很短的时间。</li>
<li>然后，我似乎学会了什么，但后来好像又忘记不少。</li>
<li>很有可能，我阅读理解的能力不够。</li>
</ul>
<p>其实这是很正常的一件事，在这个信息化的时代，很多算法，很多媒体都为我们高效地提供了所需的信息，我们站在一个非常“懵懂”的理解角度去理解这些信息，这些咨询给我们带来的知识上的补充。</p>
<p>然而这些补充，如果不经大脑思考，只是以记忆存储的方式保留在我们的大脑里，很容易就会被遗忘。读小说时，我们会遗忘书中的主人公，会遗忘故事的主线，会遗忘这个故事在讲什么；读科普类书时，我们会遗忘一些概念，一些知识点。</p>
<ul>
<li>其实就我而言，这些知识是重要的，但也不是那么重要的。</li>
<li>思维的变迁，理解能力的提升，似乎是一个更需要我们当代人理解的维度。
<ul>
<li>为什么？怎么做？似乎比 是什么？更重要。</li>
</ul></li>
</ul>
<p>想一下，“听” 和 “读” 似乎是一个被动式的学习方式，而 “说” 和 “写” 更能反映这个人的才华输出，似乎更能为人所敬佩，我想我们很多人都想成为一个懂得才华输出的人。</p>
<p><strong>我们需要主动的阅读，这样的效果会更好。</strong></p>
<p>主动的阅读一定是带有目的性的，是我们想要获取知识，技巧，或者纯粹为了消遣而去读书的，但总比不想读书，只是简单地浏览互联网获取知识要好很多。它多就多在，主动权在你手里，你有这个想法去做很多人懒得做的事，它能让你以一个比较积极向上的方式去获取你想得到的东西。</p>
<p><strong>我们需要为了资讯而读书，更要为求得理解而读书。</strong></p>
<p>知识当然重要，它会成为你在他人面前炫耀的一种资本，但是理解力更重要，它能使得你在人际关系的处理过程中，更加清楚对方的需求与目的，也能让你在生活中面对一切苦难都能做到游刃有余。</p>
<p><strong>阅读就是学习，一种自我发现型的学习。</strong></p>
<p>没有了老师的点拨，就需要我们自我学习，这种学习方式是自我沉浸在思维的海洋中，利用自身的能力去不断拔高自己的理解力，衡量理解力的标准就是当前你手中阅读的那本书，它会告诉你，标准就在那，你能不能触及，得看你自己。</p>
<p>当然，值得一提的是，我们也可以在阅读过程中请教他人，因为任何思维的碰撞都是有必要的，不仅在自我追寻中，更有在与他人的交流中。</p>
<p><strong>阅读获取知识不是最终目的，它也能成为完善自我人格的一种方式。</strong></p>
<blockquote>
<p>于 20210516 有感</p>
</blockquote>
<h2 id="第二章-阅读的层次">第二章 阅读的层次</h2>
]]></content>
      <categories>
        <category>文学</category>
      </categories>
      <tags>
        <tag>文学</tag>
      </tags>
  </entry>
  <entry>
    <title>【文学】《进化心理学》书评</title>
    <url>/2021/07/30/%E3%80%90%E6%96%87%E5%AD%A6%E3%80%91%E3%80%8A%E8%BF%9B%E5%8C%96%E5%BF%83%E7%90%86%E5%AD%A6%E3%80%8B%E4%B9%A6%E8%AF%84/</url>
    <content><![CDATA[<blockquote>
<p>原书作者: [美国] 戴维·巴斯，书评-始2021年07年30日记录。</p>
</blockquote>
<span id="more"></span>
<p><strong>进化层次下的心理学</strong>。</p>
<p>在现而今的意识形态下，达尔文的自然选择理论（进化论）似乎说明了很多生物发展的目的：“物竞天择，适者生存。”一切都为了更好地活下去。在生理层面上，“进化”理论占得一席之地，那么在心理层面呢？答案是肯定的，在为了生存的道路上，各类生物（尤其是人类，本书主要的研究对象也是人）在心理层面也不谋而合得产生了 <strong>“适应器”</strong> ——为了更好生存的一种“保护机制”。这种“适应器”，让人类在各自的心理上，各类关系的选择上都产生了重大的作用。以进化的方式看待心理学似乎是一种特别的学问。</p>
<p><strong>一切为了生存</strong>。</p>
<p>发展自己为了什么，为了生存。近些日子，和朋友聊起“娱乐圈吴亦凡的丑闻”以及其“后援兵”的故事，有些深恶痛绝，或者说是很令人不屑。细细想来，如果站在某些角度，也能理解这种种异化的行为，社会发展的形态，初级阶段的国情，人性的丑陋，只不过在一些机缘巧合下牵制在一起，于是道德感沦丧了，这也是社会发展的异化。进化理论中难以排斥的一部分就是'变异'，无论生理，还是心理层面。</p>
<p>就拿“吴亦凡”这类事举个例子，“娱乐圈”是个高暴利场所，一些人通过自己在“娱乐”方面的突出能力，在人们心中留下了深深的烙印（每个人都想享乐，也就会很自然地喜欢上会制造快乐的人）。对于“吴亦凡”这类人来说，当一些生活必须得到满足后，必然会想到其他物质欲望（这些比较低层次的欲望线），于是金钱，美女，美酒，毒品——各种能“唤醒”人欲望快乐的多巴胺，都成了这些人——或者说是欲望傀儡的目标。这是一种“进化”过程中的“变异”，不好的“变异”。</p>
<p>我们生而为人，在努力奋斗得到自身能够活下去的条件下后，必然会有更多“愿望”，无论是金钱还是什么，都可以成为我们赖以生存下去的原因之一，这是无可非议的。但是选择是靠我们自己去选择的，我们可以理性选择。<strong>一切不太适合的选择似乎都源于我们对自身的不了解，却依旧想着做成别人的样子。</strong> 我们当然想要有一个比较好的关系，我们当然都想组建一个比较好的家庭，而这些心理都和进化似乎息息相关。</p>
<p><strong>寻找人生的另一半</strong>。</p>
<p>不得不说，这本书写了很多关于“择偶”方面的“大事”，确实，选择一个愿意和自己一起共同面对生活坎坷的另一半是十分重要的，他/她不仅能带给你所需，也能帮助你成为更好的自己。<strong>或者从进化角度自私地说上一句，每个人的基因都想更好地延续下去</strong>。其实男性和女性并不是“火星与地球上两种不同的生物”，从很多层面上来讲，大家的需求都差不多。只不过男生和女生在择偶层面上所付出的精力和代价是不大一致的（这可能也会导致一些女权主义的偏见），这里就不展开说了。不过值得注意的是，这些精力和代价会潜在地影响我们的选择，同时也会影响我们对待“爱”的认知——一般都是不太理性的。</p>
<p><strong>总要适应社会</strong>。</p>
<p>人不是单独的个体，而是社会的一部分，没有人能脱离社会活下去。正是因为这种刻在骨子里的“抱团取暖”意识，才让我们人类（智人）在历史的长河下发展地如此迅猛。我们需要“领袖”，需要“朋友”，需要“爱人”；我们也需要“合作”，需要“竞争”；我们更需要内心的愉悦与充实，需要在社会有立足之地。而这些都得益于 <strong>自己能否以一个健全的姿态，认识是非，不断学习，从更高的维度去展望未来</strong>，人总要“进化”的，这种“进化”似乎也暗示着自己的不断成长。一起加油吧！</p>
<p><strong>一本从进化角度探究心理学的书籍</strong>。</p>
<p>心理学被划分为很多层类，但能否用“进化”一词去统一“心理学”仍是研究热点。本书通过一些实验科学论证了“进化”与“心理学”之间密切的关系，但是众说纷纭，人在了解自己是个怎样的人的道路上仍然需要更加努力。</p>
<hr />
<blockquote>
<p>目录部分。</p>
</blockquote>
<ul>
<li><strong>第一部分 进化心理学基础理论</strong>
<ul>
<li>第一章 导致进化心理学产生的科学运动</li>
<li>第二章 作为新科学的进化心理学</li>
</ul></li>
<li><strong>第二部分 生存问题</strong>
<ul>
<li>第三章 克服恶劣的自然条件</li>
</ul></li>
<li><strong>第三部分 性行为和择偶行为的挑战</strong>
<ul>
<li>第四章 女性的长期择偶策略</li>
<li>第五章 男性的长期择偶策略</li>
<li>第六章 短期的性关系策略</li>
</ul></li>
<li><strong>第四部分 亲代抚育和亲属关系的挑战</strong>
<ul>
<li>第七章 亲代抚育问题</li>
<li>第八章 亲属关系问题</li>
</ul></li>
<li><strong>第五部分 群居问题</strong>
<ul>
<li>第九章 合作联盟</li>
<li>第十章 攻击与战争</li>
<li>第十一章 两性冲突</li>
<li>第十二章 地位、声望与社会支配</li>
</ul></li>
<li><strong>第六部分 一门整合的心理科学</strong>
<ul>
<li>第十三章 走向统一的进化心理学</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>文学</category>
      </categories>
      <tags>
        <tag>文学</tag>
        <tag>心理学</tag>
      </tags>
  </entry>
  <entry>
    <title>【文本处理】常用的文本处理过程</title>
    <url>/2021/07/18/%E3%80%90%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E3%80%91%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<blockquote>
<p>一些常用的文本处理过程总结（不断更新与补充）。</p>
</blockquote>
<span id="more"></span>
<h2 id="分词">分词</h2>
<h2 id="剔除一些无用的符号词">剔除一些无用的符号，词</h2>
<h2 id="三种统计词频的方式">三种统计词频的方式</h2>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/26716150">参考</a></li>
</ul>
<h3 id="直接使用-dict">直接使用 dict</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">text = <span class="string">&quot;I&#x27;m a handsome boy!&quot;</span></span><br><span class="line"></span><br><span class="line">frequency = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> text.split():</span><br><span class="line">    <span class="keyword">if</span> word <span class="keyword">not</span> <span class="keyword">in</span> frequency:</span><br><span class="line">        frequency[word] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        frequency[word] += <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="使用-defaultdict">使用 defaultdict</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line">frequency = collections.defaultdict(<span class="built_in">int</span>)</span><br><span class="line"></span><br><span class="line">text = <span class="string">&quot;I&#x27;m a handsome boy!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> text.split():</span><br><span class="line">    frequency[word] += <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="使用-counter">使用 Counter</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line">text = <span class="string">&quot;I&#x27;m a handsome boy!&quot;</span></span><br><span class="line">frequency = collections.Counter(text.split())</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>文本处理</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>文本处理</tag>
      </tags>
  </entry>
  <entry>
    <title>【机器学习】潜在狄利克雷分配（LDA）</title>
    <url>/2021/07/09/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%91%E6%BD%9C%E5%9C%A8%E7%8B%84%E5%88%A9%E5%85%8B%E9%9B%B7%E5%88%86%E9%85%8D%EF%BC%88LDA%EF%BC%89/</url>
    <content><![CDATA[<blockquote>
<p>主要介绍了如何使用潜在狄利克雷分配（LDA）—— 主题聚类。</p>
</blockquote>
<span id="more"></span>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://www.machinelearningplus.com/nlp/topic-modeling-visualization-how-to-present-results-lda-models/#1.-Introduction">Topic modeling visualization – How to present the results of LDA models?</a></li>
</ul>
]]></content>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>【机器学习】L0-绪论</title>
    <url>/2021/07/03/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%91L0-%E7%BB%AA%E8%AE%BA/</url>
    <content><![CDATA[<blockquote>
<p>以两种不同的视角回顾机器学习的部分学习资料。</p>
<ul>
<li><p>频率派 - 统计机器学习</p></li>
<li><p>贝叶斯派 - 概率图模型</p></li>
</ul>
<p>如何看待不同视角下的机器学习？ 频率派 VS 贝叶斯派</p>
</blockquote>
<span id="more"></span>
<h2 id="经典书籍推荐">经典书籍推荐</h2>
<ul>
<li><strong>《统计机器学习》 - 李航（第一版）</strong>
<ul>
<li>十二章，最常用的十个算法（感 K 朴决逻，支提 E 隐条）</li>
<li>大面积讲 - 频率派</li>
</ul></li>
<li><strong>“西瓜书” - 周志华</strong>
<ul>
<li>比较全面，既有频率派，又有贝叶斯派</li>
</ul></li>
<li><strong>PRML</strong>
<ul>
<li>回分神核稀，图混近采连</li>
<li>主要是贝叶斯派</li>
</ul></li>
<li>MLAPP
<ul>
<li>百科全书</li>
<li>主要是贝叶斯派</li>
</ul></li>
<li>ESL
<ul>
<li>主要是频率派</li>
</ul></li>
<li>Deep Learning （圣经）- 中译版（张志华）</li>
</ul>
<h2 id="经典视频推荐">经典视频推荐</h2>
<ul>
<li><strong>台大 - 林轩田 - 基石 + 技法</strong></li>
<li>张志华
<ul>
<li>机器学习导论 - 频率派</li>
<li>统计机器学习 - 贝叶斯</li>
</ul></li>
<li>Ng: CS229
<ul>
<li>有数学推导</li>
</ul></li>
<li>徐亦达
<ul>
<li>概率模型</li>
</ul></li>
<li><strong>台大 - 李宏毅：机器学习</strong></li>
</ul>
<hr />
<h2 id="频率派-vs-贝叶斯派">频率派 VS 贝叶斯派</h2>
<h3 id="一些标记">一些标记</h3>
<ul>
<li>对数据集（观测集）采用以下标记：
<ul>
<li><span class="math inline">\(X_{N \times p}\)</span> : 数据集（观测集）
<ul>
<li><span class="math inline">\(X_{N \times p}=\left(x_{1}, x_{2}, \cdots, x_{N}\right)^{T}\)</span>
<ul>
<li><span class="math inline">\(N\)</span> 表示样本个数，<span class="math inline">\(p\)</span> 表示每个样本的维度。</li>
</ul></li>
<li>其中每个数据样本: <span class="math inline">\(x_{i}=\left(x_{i 1}, x_{i 2}, \cdots, x_{i p}\right)^{T}\)</span></li>
</ul></li>
<li><span class="math inline">\(\Theta\)</span> : 参数</li>
</ul></li>
<li>每个数据样本 <span class="math inline">\(x \sim p(x,\Theta)\)</span>，<span class="math inline">\(\sim\)</span> 表示服从于某个分布。
<ul>
<li>即每个数据样本都是由 <span class="math inline">\(p(x,\Theta)\)</span> 生成的。</li>
</ul></li>
<li><span class="math inline">\(\color{blue}{\text{我们想要求某个样本出现的概率，但是其出现概率与其分布的参数} \Theta \text{产生某种联系，所以求出} \Theta 是十分有必要的。}\)</span></li>
</ul>
<h3 id="频率派">频率派</h3>
<blockquote>
<p>假定 <span class="math inline">\(\Theta\)</span> 是常量。</p>
</blockquote>
<ul>
<li>假设每个样本是独立同分布的，对于整个数据集来说，<span class="math inline">\(p(X \mid \Theta) \overline{\overline{i i d}} \prod_{i}^{N} p\left(x_{i} \mid \Theta\right)\)</span>
<ul>
<li>iid:independent &amp; identically distributed - 独立同分布</li>
</ul></li>
<li>为了求 <span class="math inline">\(\Theta\)</span> 的大小，采用最大对数似然估计（MLE）的方法：</li>
</ul>
<p><span class="math display">\[\Theta_{MLE}=\underset{\Theta}{\operatorname{argmax}} \log p(X \mid \Theta) \overline{\overline{i i d}} \underset{\Theta}{\operatorname{argmax}} \sum_{i=1}^{N} \log p\left(x_{i} \mid \Theta\right)\]</span></p>
<ul>
<li><span class="math inline">\(log\)</span> 的作用：将乘法变为加法，方便计算。</li>
<li>频率派的一般求解步骤为：
<ul>
<li>1.建立模型</li>
<li>2.定义损失函数</li>
<li>3.最优化损失函数</li>
</ul></li>
</ul>
<h3 id="贝叶斯派">贝叶斯派</h3>
<blockquote>
<p>假定 <span class="math inline">\(\Theta\)</span> 是变量。</p>
</blockquote>
<ul>
<li>根据贝叶斯定理，依赖观测集参数的后验概率 <span class="math inline">\(P(\Theta \mid X)\)</span> 可以写成：</li>
</ul>
<p><span class="math display">\[p(\Theta \mid X)=\frac{p(X \mid \Theta) \cdot p(\Theta)}{p(X)}=\frac{p(X \mid \Theta) \cdot p(\Theta)}{\int_{\Theta} p(X \mid \Theta) \cdot p(\Theta) d \Theta}\]</span></p>
<ul>
<li>分母 <span class="math inline">\(p(X)\)</span> 变为积分 <span class="math inline">\(\int_{\Theta} p(X \mid \Theta) \cdot p(\Theta) d \Theta\)</span> 的原因，<a href="https://baike.baidu.com/item/%E5%85%A8%E6%A6%82%E7%8E%87%E5%85%AC%E5%BC%8F">全概率公式</a>。</li>
<li><a href="https://www.zhihu.com/question/19725590">如何通俗理解贝叶斯公式的先验，后验，似然？</a></li>
<li>为了求 <span class="math inline">\(\Theta\)</span> 的大小，采用最大后验概率估计（MAP）的方法：</li>
</ul>
<p><span class="math display">\[\Theta_{M A P}=\underset{\Theta}{\operatorname{argmax}} p(\Theta \mid X)=\underset{\Theta}{\operatorname{argmax}} p(X \mid \Theta) \cdot p(\Theta)\]</span></p>
<ul>
<li><p>等式成立的原因是分母 <span class="math inline">\(p(X)\)</span> 与 <span class="math inline">\(\Theta\)</span> 无关，求得 <span class="math inline">\(\Theta\)</span> 后就可计算参数的后验概率 <span class="math inline">\(p(\Theta \mid X)\)</span></p></li>
<li>贝叶斯估计：<span class="math inline">\(p(\Theta \mid X)=\frac{p(X \mid \Theta) \cdot p(\Theta)}{p(X)}=\frac{p(X \mid \Theta) \cdot p(\Theta)}{\int_{\Theta} p(X \mid \Theta) \cdot p(\Theta) d \Theta}\)</span></li>
<li><p>贝叶斯预测：已知数据集 <span class="math inline">\(X\)</span> 的分布，现在给一个新的样本 <span class="math inline">\(\hat{x}\)</span>，求其出现的概率 <span class="math inline">\(P(\hat{x}|X)\)</span> 的值，<strong>注意 <span class="math inline">\(\hat{x}\)</span> 与 <span class="math inline">\(X\)</span> 是独立同分布的</strong>。</p></li>
</ul>
<p><span class="math display">\[p(\hat{x} \mid X) = \int_{\Theta} p(\hat{x},\Theta \mid X) d \Theta = \int_{\Theta} p(\hat{x} \mid \Theta) \cdot p(\Theta \mid X) d \Theta\]</span></p>
<ul>
<li>第一个等号，参考<a href="https://baike.baidu.com/item/%E8%BE%B9%E7%BC%98%E5%88%86%E5%B8%83%E5%87%BD%E6%95%B0/353094">边缘分布函数公式</a></li>
<li>第二个等号，参考<a href="https://baike.baidu.com/item/%E6%9D%A1%E4%BB%B6%E6%A6%82%E7%8E%87">条件概率</a>逆推即可：<span class="math inline">\(P( {\color{red}{\hat{x},\Theta}} \mid X) = P( {\color{red}{\hat{x}} \mid \Theta} \mid X)P( {\color{red}{\Theta}} \mid X)\)</span></li>
</ul>
<h2 id="总结">总结</h2>
<blockquote>
<p>贝叶斯派角度，概率图模型，是求积分的问题，MCMC、Carlo 方法。</p>
<p>频率派角度，统计机器学习，是优化的问题，模型-损失函数-优化。</p>
</blockquote>
<h2 id="白板">白板</h2>
<figure>
<img src="https://user-images.githubusercontent.com/48743005/124381311-646e1900-dcf4-11eb-9794-662af5bf3876.png" alt="Fig 1 c0-绪论1" /><figcaption>Fig 1 c0-绪论1</figcaption>
</figure>
<figure>
<img src="https://user-images.githubusercontent.com/48743005/124381317-6932cd00-dcf4-11eb-813f-14c4b0ab59f3.png" alt="Fig 2 c0-绪论2" /><figcaption>Fig 2 c0-绪论2</figcaption>
</figure>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://www.bilibili.com/video/BV1aE411o7qd?">【机器学习】【白板推导系列】【合集 1～23】</a></li>
<li><a href="https://www.jianshu.com/nb/46548929">机器学习推导系列</a></li>
<li><a href="https://www.yuque.com/books/share/f4031f65-70c1-4909-ba01-c47c31398466?#">Bilibili-机器学习白板系列</a></li>
</ul>
]]></content>
      <categories>
        <category>机器学习-白板系列</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>【科普】Unicode 编码</title>
    <url>/2021/07/16/%E3%80%90%E7%A7%91%E6%99%AE%E3%80%91Unicode-%E7%BC%96%E7%A0%81/</url>
    <content><![CDATA[<blockquote>
<p>简要介绍了 Unicode 编码问题。</p>
</blockquote>
<span id="more"></span>
<h1 id="unicode-编码">Unicode 编码</h1>
<hr />
<h2 id="ascii码">ASCII码</h2>
<p>在学校学 C 语言的时候，了解到一些计算机内部的机制，知道所有的信息最终都表示为一个二进制的字符串，每一个二进制位有 0 和 1 两种状态，通过不同的排列组合，使用 0 和 1 就可以表示世界上所有的东西，感觉有点中国“太极”的感觉——“太极生两仪，两仪生四象，四象生八卦”。</p>
<p>在计算机种中，1 字节对应 8 位二进制数，而每位二进制数有 0、1 两种状态，因此 1 字节可以组合出 256 种状态。如果这 256 中状态每一个都对应一个符号，就能通过 1 字节的数据表示 256 个字符。美国人于是就制定了一套编码（其实就是个字典），描述英语中的字符和这 8 位二进制数的对应关系，这被称为 ASCII 码。</p>
<p>ASCII 码一共定义了 128 个字符，例如大写的字母 A 是 65（这是十进制数，对应二进制是0100 0001）。这 128 个字符只使用了 8 位二进制数中的后面 7 位，最前面的一位统一规定为 0。</p>
<hr />
<h2 id="历史问题">历史问题</h2>
<p>英语用 128 个字符来编码完全是足够的，但是用来表示其他语言，128 个字符是远远不够的。于是，一些欧洲的国家就决定，将 ASCII 码中闲置的最高位利用起来，这样一来就能表示 256 个字符。但是，这里又有了一个问题，那就是不同的国家的字符集可能不同，就算它们都能用 256 个字符表示全，但是同一个码点（也就是 8 位二进制数）表示的字符可能可能不同。例如，144 在阿拉伯人的 ASCII 码中是<code>گ</code>，而在俄罗斯的 ASCII 码中是 <code>ђ</code>。</p>
<p>因此，ASCII 码的问题在于尽管所有人都在 0 - 127 号字符上达成了一致，但对于 128 - 255 号字符上却有很多种不同的解释。与此同时，亚洲语言有更多的字符需要被存储，一个字节已经不够用了。于是，人们开始使用两个字节来存储字符。</p>
<p>各种各样的编码方式成了系统开发者的噩梦，因为他们想把软件卖到国外。于是，他们提出了一个“内码表”的概念，可以切换到相应语言的一个内码表，这样才能显示相应语言的字母。在这种情况下，如果使用多语种，那么就需要频繁的在内码表内进行切换。</p>
<hr />
<h2 id="unicode">Unicode</h2>
<p>最终，美国人意识到他们应该提出一种标准方案来展示世界上所有语言中的所有字符，出于这个目的，Unicode诞生了。</p>
<p>Unicode 当然是一本很厚的字典，记录着世界上所有字符对应的一个数字。具体是怎样的对应关系，又或者说是如何进行划分的，就不是我们考虑的问题了，我们只用知道 Unicode 给所有的字符指定了一个数字用来表示该字符。</p>
<p>对于 Unicode 有一些误解，它仅仅只是一个字符集，规定了符合对应的二进制代码，至于这个二进制代码如何存储则没有任何规定。它的想法很简单，就是为每个字符规定一个 用来表示该字符的数字，仅此而已。</p>
<hr />
<h2 id="unicode-编码方案">Unicode 编码方案</h2>
<p>之前提到，Unicode 没有规定字符对应的二进制码如何存储。以汉字“汉”为例，它的 Unicode 码点是 <code>0x6c49</code>，对应的二进制数是 <code>110110001001001</code>，二进制数有 <code>15</code> 位，这也就说明了它至少需要 <code>2</code> 个字节来表示。可以想象，在 Unicode 字典中往后的字符可能就需要 <code>3</code> 个字节或者 <code>4</code> 个字节，甚至更多字节来表示了。</p>
<p>这就导致了一些问题，计算机怎么知道你这个 <code>2</code> 个字节表示的是<code>一</code>个字符，而不是分别表示<code>两</code>个字符呢？这里我们可能会想到，那就取个最大的，假如 Unicode 中最大的字符用 <code>4</code> 字节就可以表示了，那么我们就将所有的字符都用 <code>4</code> 个字节来表示，不够的就往前面补 <code>0</code>。这样确实可以解决编码问题，但是却造成了空间的极大浪费，如果是一个英文文档，那文件大小就大出了 <code>3</code> 倍，这显然是无法接受的。</p>
<p>于是，<strong>为了较好的解决 Unicode 的编码问题</strong>， UTF-8 和 UTF-16 两种当前比较流行的编码方式诞生了。当然还有一个 UTF-32 的编码方式，也就是上述那种定长编码，字符统一使用 4 个字节，虽然看似方便，但是却不如另外两种编码方式使用广泛。</p>
<hr />
<h2 id="utf-8">UTF-8</h2>
<p>UTF-8 是一个非常惊艳的编码方式，漂亮的实现了对 ASCII 码的向后兼容，以保证 Unicode 可以被大众接受。</p>
<p>UTF-8 是目前互联网上使用最广泛的一种 Unicode 编码方式，它的最大特点就是可变长。它可以使用 1 - 4 个字节表示一个字符，根据字符的不同变换长度。编码规则如下：</p>
<p>对于单个字节的字符，第一位设为 0，后面的 7 位对应这个字符的 Unicode 码点。因此，对于英文中的 0 - 127 号字符，与 ASCII 码完全相同。这意味着 ASCII 码那个年代的文档用 UTF-8 编码打开完全没有问题。 对于需要使用 N 个字节来表示的字符（N &gt; 1），第一个字节的前 N 位都设为 1，第 N + 1 位设为0，剩余的 N - 1 个字节的前两位都设位 10，剩下的二进制位则使用这个字符的 Unicode 码点来填充。 编码规则如下：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Unicode 十六进制码点范围</th>
<th style="text-align: center;">UTF-8 二进制</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">0000 0000 - 0000 007F</td>
<td style="text-align: center;">0xxxxxxx</td>
</tr>
<tr class="even">
<td style="text-align: center;">0000 0080 - 0000 07FF</td>
<td style="text-align: center;">110xxxxx 10xxxxxx</td>
</tr>
<tr class="odd">
<td style="text-align: center;">0000 0800 - 0000 FFFF</td>
<td style="text-align: center;">1110xxxx 10xxxxxx 10xxxxxx</td>
</tr>
<tr class="even">
<td style="text-align: center;">0001 0000 - 0010 FFFF</td>
<td style="text-align: center;">11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</td>
</tr>
</tbody>
</table>
<p>根据上面编码规则对照表，进行 UTF-8 编码和解码就简单多了。</p>
<p><em>下面以汉字“汉”为例，具体说明如何进行 UTF-8 编码和解码。</em></p>
<p>“汉”的 Unicode 码点是 <code>0x6c49</code>（<code>110 1100 0100 1001</code>），通过上面的对照表可以发现，<code>0x0000 6c49</code> 位于第三行的范围，那么得出其格式为 <code>1110xxxx 10xxxxxx 10xxxxxx</code>。接着，从“汉”的二进制数最后一位开始，从后向前依次填充对应格式中的 x，多出的 x 用 0 补上。这样，就得到了“汉”的 <code>UTF-8</code> 编码为 <code>11100110 10110001 10001001</code>，转换成十六进制就是 <code>0xE6 0xB7 0x89</code>。</p>
<p>解码的过程也十分简单：如果一个字节的第一位是 0 ，则说明这个字节对应一个字符；如果一个字节的第一位1，那么连续有多少个 1，就表示该字符占用多少个字节。</p>
<hr />
<h2 id="utf-16">UTF-16</h2>
<p>在了解 UTF-16 编码方式之前，先了解一下另外一个概念——&quot;平面&quot;。</p>
<p>在上面的介绍中，提到了 Unicode 是一本很厚的字典，她将全世界所有的字符定义在一个集合里。这么多的字符不是一次性定义的，而是分区定义。每个区可以存放 65536 个（<span class="math inline">\(2^{16}\)</span>）字符，称为一个平面（plane）。目前，一共有 17 个（<span class="math inline">\(2^{5}\)</span>）平面，也就是说，整个 Unicode 字符集的大小现在是 <span class="math inline">\(2^{21}\)</span>。</p>
<p>最前面的 65536 个字符位，称为基本平面（简称 BMP ），它的码点范围是从 0 到 <span class="math inline">\(2^{16}-1\)</span>，写成 16 进制就是从 <code>U+0000</code> 到 <code>U+FFFF</code>。所有最常见的字符都放在这个平面，这是 Unicode 最先定义和公布的一个平面。剩下的字符都放在辅助平面（简称 SMP ），码点范围从 <code>U+010000</code> 到 <code>U+10FFFF</code>。</p>
<p>基本了解了平面的概念后，再说回到 UTF-16。UTF-16 编码介于 UTF-32 与 UTF-8 之间，同时结合了定长和变长两种编码方法的特点。它的编码规则很简单：基本平面的字符占用 2 个字节，辅助平面的字符占用 4 个字节。也就是说，UTF-16 的编码长度要么是 2 个字节（<code>U+0000 到 U+FFFF</code>），要么是 4 个字节（<code>U+010000 到 U+10FFFF</code>）。那么问题来了，当我们遇到两个字节时，到底是把这两个字节当作一个字符还是与后面的两个字节一起当作一个字符呢？</p>
<p>这里有一个很巧妙的地方，在基本平面内，从 <code>U+D800</code> 到 <code>U+DFFF</code> 是一个空段，即这些码点不对应任何字符。因此，这个空段可以用来映射辅助平面的字符。</p>
<p>辅助平面的字符位共有 <span class="math inline">\(2^{20}\)</span> 个，因此表示这些字符至少需要 20 个二进制位。UTF-16 将这 20 个二进制位分成两半，前 10 位映射在 <code>U+D800</code> 到 <code>U+DBFF</code>，称为高位（H），后 10 位映射在 <code>U+DC00</code> 到 <code>U+DFFF</code>，称为低位（L）。这意味着，一个辅助平面的字符，被拆成两个基本平面的字符表示。</p>
<p>因此，当我们遇到两个字节，发现它的码点在 U+D800 到 U+DBFF 之间，就可以断定，紧跟在后面的两个字节的码点，应该在 U+DC00 到 U+DFFF 之间，这四个字节必须放在一起解读。</p>
<p><strong>例子：</strong></p>
<p><img src="https://user-images.githubusercontent.com/48743005/125929324-037eef96-4289-4230-a96b-7a3e23a81590.png" /></p>
<p>接下来，以汉字&quot;ji&quot;(见上图)为例，说明 UTF-16 编码方式是如何工作的。</p>
<p>汉字&quot;ji&quot;的 Unicode 码点为 <code>0x20BB7</code>，该码点显然超出了基本平面的范围（<code>0x0000 - 0xFFFF</code>），因此需要使用四个字节表示。首先用 <code>0x20BB7 - 0x10000</code> 计算出超出的部分，然后将其用 20 个二进制位表示（不足前面补 0 ），结果为<code>0001000010 1110110111</code>。接着，将前 10 位映射到 <code>U+D800</code> 到 <code>U+DBFF</code> 之间，后 10 位映射到 <code>U+DC00</code> 到 <code>U+DFFF</code> 即可。<code>U+D800</code> 对应的二进制数为 <code>1101100000000000</code>，直接填充后面的 10 个二进制位即可，得到 <code>1101100001000010</code>，转成 16 进制数则为 <code>0xD842</code>。同理可得，低位为 <code>0xDFB7</code>。因此得出汉字&quot;ji&quot;的 UTF-16 编码为 <code>0xD842 0xDFB7</code>。</p>
<p>Unicode3.0 中给出了辅助平面字符的转换公式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">H = Math.floor((c-<span class="number">0x10000</span>) / <span class="number">0x400</span>)+<span class="number">0xD800</span></span><br><span class="line"></span><br><span class="line">L = (c - <span class="number">0x10000</span>) % <span class="number">0x400</span> + <span class="number">0xDC00</span></span><br></pre></td></tr></table></figure>
<p>根据编码公式，可以很方便的计算出字符的 UTF-16 编码。</p>
]]></content>
      <categories>
        <category>科普</category>
      </categories>
      <tags>
        <tag>Unicode</tag>
      </tags>
  </entry>
  <entry>
    <title>【社区检测】PageRank算法及其改进算法LeaderRank介绍</title>
    <url>/2021/07/06/%E3%80%90%E7%A4%BE%E5%8C%BA%E6%A3%80%E6%B5%8B%E3%80%91PageRank%E7%AE%97%E6%B3%95%E5%8F%8A%E5%85%B6%E6%94%B9%E8%BF%9B%E7%AE%97%E6%B3%95LeaderRank%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://en.wikipedia.org/wiki/PageRank">PageRank</a> 算法，网页排名，又称网页级别或佩奇排名，是一种根据网页间相互超链接进行网页排名的技术，以Google公司创办人拉里·佩奇（Larry Page）之姓来命名。</p>
<p><a href="https://www.centiserver.org/centrality/LeaderRank/">LeaderRank</a> 算法，PageRank 的改进版本。</p>
</blockquote>
<span id="more"></span>
<hr />
<h2 id="简要介绍">简要介绍</h2>
<blockquote>
<p>由于网上有很多关于这个算法的原理描述，这里就简单地说下，不多做介绍了，想了解地更详细的话，可以参考下面的链接。</p>
</blockquote>
<figure>
<img src="https://user-images.githubusercontent.com/48743005/124621289-bbb6e980-deac-11eb-919a-98405722bae3.jpg" alt="Fig.PageRank" /><figcaption>Fig.PageRank</figcaption>
</figure>
<ul>
<li>PageRank
<ul>
<li>每个网页可以当做一个节点，节点与节点之间有向图连接（即形成关系）；</li>
<li>初始情况下，用户在所有网页上浏览的概率可以是 <span class="math inline">\(P=\frac{1}{n}\)</span>，和为1；</li>
<li>随着时间（迭代次数）的更进，页面的值会通过（投票）算法不断迭代，直至达到平稳分布为止。
<ul>
<li>这种（投票）算法和不同节点的出度数目有关，会形成一个出度的概率转移矩阵。</li>
</ul></li>
</ul></li>
</ul>
<figure>
<img src="https://user-images.githubusercontent.com/48743005/124624413-6defb080-deaf-11eb-882c-8befdd6f9a69.png" alt="Fig.LeaderRank" /><figcaption>Fig.LeaderRank</figcaption>
</figure>
<ul>
<li>LeaderRank
<ul>
<li>在基本的 Pagerank 算法基础上，LeaderRank 增加一个背景节点与所有节点进行双向连接。这个新的网络成了一个强连通网络，修复了基本的 Pagerank 算法的一些问题。</li>
</ul></li>
</ul>
<h2 id="重要公式">重要公式</h2>
<hr />
<h3 id="pagerank">PageRank</h3>
<p><span class="math display">\[
PR\left(p_{i}\right)=\alpha \sum_{p_{j} \in M_{p_{i}}} \frac{PR\left(p_{j}\right)}{L\left(p_{j}\right)}+\frac{(1-\alpha)}{N}
\]</span></p>
<ul>
<li>PR-PageRank</li>
<li>式子是 PageRank 的修正版计算方式
<ul>
<li><span class="math inline">\(PR(p_j)\)</span>：网页 <span class="math inline">\(p_j\)</span> 的 LeaderRank 值</li>
<li><span class="math inline">\(\alpha\)</span>：阻尼系数，一般取 0.85，解决某个节点-环的问题</li>
<li><span class="math inline">\(M_{p_i}\)</span>：指向 <span class="math inline">\(p_i\)</span> 网页的网页集合</li>
<li><span class="math inline">\(L(p_j)\)</span>：网页 <span class="math inline">\(p_j\)</span> 的出度</li>
<li>注意，<span class="math inline">\(\alpha\)</span> 和 <span class="math inline">\(\frac{(1-\alpha)}{N}\)</span> 的引入主要是为了解决节点带环的问题</li>
<li><span class="math inline">\(N\)</span>：节点个数</li>
</ul></li>
</ul>
<hr />
<h3 id="不带加权的-leaderrank-pagerank的改进版">不带加权的 LeaderRank （PageRank的改进版）</h3>
<p><span class="math display">\[
LR\left(p_{i}\right)=\alpha \sum_{p_{j} \in M_{p_{i}}} \frac{LR\left(p_{j}\right)}{L\left(p_{j}\right)}+\frac{(1-\alpha)}{N}
\]</span></p>
<p><span class="math display">\[
LR(p_i) = LR(p_i) + \frac{\hat{LR}(p_g)}{N}
\]</span></p>
<ul>
<li>LR-LeaderRank</li>
<li>第一个式子是 PageRank 的修正版计算方式（这里因为是 LeaderRank，用 LR 标记）
<ul>
<li><span class="math inline">\(LR(p_j)\)</span>：网页 <span class="math inline">\(p_j\)</span> 的 LeaderRank 值</li>
<li><span class="math inline">\(\alpha\)</span>：阻尼系数，一般取 0.85，解决某个节点-环的问题</li>
<li><span class="math inline">\(M_{p_i}\)</span>：指向 <span class="math inline">\(p_i\)</span> 网页的网页集合</li>
<li><span class="math inline">\(L(p_j)\)</span>：网页 <span class="math inline">\(p_j\)</span> 的出度</li>
<li>注意，<span class="math inline">\(\alpha\)</span> 和 <span class="math inline">\(\frac{(1-\alpha)}{N}\)</span> 的引入主要是为了解决节点带环的问题</li>
<li><span class="math inline">\(N\)</span>：节点个数</li>
</ul></li>
<li>第二个式子是 LeaderRank 的计算方式
<ul>
<li><span class="math inline">\(p_g\)</span>：增加的一个 g 节点</li>
<li><span class="math inline">\(\hat{LR}(p_g)\)</span>：稳定状态下节点 g 节点的 LR 值</li>
</ul></li>
</ul>
<hr />
<h3 id="带加权的-leaderrankleaderrank的改进版">带加权的 LeaderRank（LeaderRank的改进版）</h3>
<p><span class="math display">\[
LR\left(p_{i}\right)=\alpha \sum_{p_{j} \in M_{p_{i}}} LR(p_{j})w_{p_{j}}+\frac{(1-\alpha)}{N}
\]</span></p>
<p><span class="math display">\[
LR(p_i) = LR(p_i) + \frac{\hat{LR}(p_g)}{N}
\]</span></p>
<ul>
<li>这里不同的地方主要是 <span class="math inline">\(w_{p_{j}}=\frac{w_j}{\sum w}\)</span>，表示权值的占比
<ul>
<li>即：当前 <span class="math inline">\(p_j\)</span> 与 <span class="math inline">\(p_i\)</span> 的权值 / 当前 <span class="math inline">\(p_j\)</span> 连接所有网页节点的权值</li>
</ul></li>
</ul>
<h2 id="数据格式">数据格式</h2>
<ul>
<li>文件命名为 “demo_data.xlsx”，保存在当前目录下</li>
</ul>
<figure>
<img src="https://user-images.githubusercontent.com/48743005/124628611-37b43000-deb3-11eb-9b72-f618496b7e0a.png" alt="Fig.demo_data.xlsx" /><figcaption>Fig.demo_data.xlsx</figcaption>
</figure>
<h2 id="代码参考">代码参考</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># LeaderRank 的带权和不带权实现。</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> networkx <span class="keyword">as</span> nx</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_excel2data</span>(<span class="params">path</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    读取 Excel 数据</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> pd.read_excel(path)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_data</span>(<span class="params">data</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    构建关系图</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 构建图</span></span><br><span class="line">    dg = nx.MultiDiGraph()<span class="comment">#.adjacency()#.predecessors(node)</span></span><br><span class="line">    <span class="comment"># 构建图节点，将所有不重复节点找出，假设每个节点都存在关系</span></span><br><span class="line">    node_ = data.iloc[:,<span class="number">1</span>].drop_duplicates().values.tolist()</span><br><span class="line">    dg.add_nodes_from(node_)</span><br><span class="line">    <span class="comment"># 构建关系</span></span><br><span class="line">    data = data.iloc[:,<span class="number">1</span>:]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(data.shape[<span class="number">0</span>]):</span><br><span class="line">        tmp = data.iloc[i,:].values.tolist()</span><br><span class="line">        dg.add_edge(tmp[<span class="number">0</span>],tmp[<span class="number">1</span>],weight=tmp[<span class="number">2</span>])</span><br><span class="line">    <span class="keyword">return</span> dg</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRModel</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    计算图的 leader rank</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, dg</span>):</span></span><br><span class="line">        self.damping_factor = <span class="number">0.85</span>  <span class="comment"># 阻尼系数,即α</span></span><br><span class="line">        self.max_iterations = <span class="number">100</span>  <span class="comment"># 最大迭代次数</span></span><br><span class="line">        self.min_delta = <span class="number">0.00001</span>  <span class="comment"># 确定迭代是否结束的参数,即ϵ</span></span><br><span class="line">        self.graph = dg</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">leader_rank</span>(<span class="params">self, mode=<span class="number">0</span></span>):</span></span><br><span class="line">        <span class="comment">#  先将图中没有出链的节点改为对所有节点都有出链</span></span><br><span class="line">        <span class="comment"># print(dict(self.graph._adj.items())[&#x27;A&#x27;])</span></span><br><span class="line">        <span class="keyword">for</span> n, nbrsdict <span class="keyword">in</span> self.graph.adjacency():</span><br><span class="line">            <span class="comment"># print(n,nbrsdict)</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(nbrsdict) == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">for</span> n2 <span class="keyword">in</span> self.graph.nodes():</span><br><span class="line">                    self.graph.add_edge(n, n2)</span><br><span class="line">            </span><br><span class="line">        <span class="comment">############################ LeaderRank，与 PageRank 不同部分 ###############################</span></span><br><span class="line">        <span class="comment"># 增加 g 节点，并且与所有节点进行连接</span></span><br><span class="line">        self.graph.add_node(<span class="string">&#x27;g&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> self.graph.nodes():</span><br><span class="line">            <span class="keyword">if</span> node != <span class="string">&#x27;g&#x27;</span>: <span class="comment"># 增加了除g以外所有点的双向边</span></span><br><span class="line">                self.graph.add_edge(<span class="string">&#x27;g&#x27;</span>, node, weight=<span class="number">1</span>) <span class="comment"># 这里权值是可以改变的</span></span><br><span class="line">                self.graph.add_edge(node, <span class="string">&#x27;g&#x27;</span>, weight=<span class="number">1</span>)</span><br><span class="line">        <span class="comment">############################ LeaderRank，删去即为 PageRank ##################################</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 所有节点</span></span><br><span class="line">        nodes = self.graph.nodes()</span><br><span class="line">        <span class="comment"># 节点个数</span></span><br><span class="line">        graph_size = <span class="built_in">len</span>(nodes)</span><br><span class="line">        <span class="comment">#print(graph_size)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> graph_size == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;</span><br><span class="line">        leader_rank = <span class="built_in">dict</span>.fromkeys(nodes, <span class="number">1.0</span> / graph_size)  <span class="comment"># 给每个节点赋予初始的PR值</span></span><br><span class="line">        <span class="comment">############################ LeaderRank，与 PageRank 不同部分 ###############################</span></span><br><span class="line">        leader_rank[<span class="string">&#x27;g&#x27;</span>] = <span class="number">0.0</span> <span class="comment"># 除了 g 节点</span></span><br><span class="line">        <span class="comment">############################ LeaderRank，删去即为 PageRank ##################################</span></span><br><span class="line">        damping_value = (<span class="number">1.0</span> - self.damping_factor) / graph_size  <span class="comment"># 公式中的(1−α)/N部分</span></span><br><span class="line"></span><br><span class="line">        flag = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.max_iterations):</span><br><span class="line">            change = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> nodes:</span><br><span class="line">                rank = <span class="number">0</span></span><br><span class="line">                <span class="keyword">for</span> predecessor <span class="keyword">in</span> <span class="built_in">list</span>(self.graph.predecessors(node)):  <span class="comment"># 遍历所有node的前继节点</span></span><br><span class="line">                    <span class="keyword">if</span> mode == <span class="number">0</span>:</span><br><span class="line">                        rank += self.damping_factor * (leader_rank[predecessor] / <span class="built_in">len</span>(<span class="built_in">list</span>(self.graph.successors(predecessor))))</span><br><span class="line">        <span class="comment">############################ LeaderRank，与 PageRank 不同部分 ###############################</span></span><br><span class="line">                    <span class="keyword">if</span> mode == <span class="number">1</span>:</span><br><span class="line">                        n_weight = self.graph.edges[predecessor, node, <span class="number">0</span>][<span class="string">&#x27;weight&#x27;</span>]</span><br><span class="line">                        <span class="comment">#print(n_weight)</span></span><br><span class="line">                        weights = <span class="number">0</span></span><br><span class="line">                        <span class="keyword">for</span> (nn, items) <span class="keyword">in</span> <span class="built_in">dict</span>(self.graph._adj.items())[predecessor].items():</span><br><span class="line">                            <span class="comment"># print(predecessor)</span></span><br><span class="line">                            <span class="comment"># print(nn, items)</span></span><br><span class="line">                            weights += items[<span class="number">0</span>][<span class="string">&#x27;weight&#x27;</span>]</span><br><span class="line">                        <span class="comment"># print(n_weight)</span></span><br><span class="line">                        <span class="comment"># print(weights)</span></span><br><span class="line">                        rank += self.damping_factor * (leader_rank[predecessor] * (n_weight/weights))</span><br><span class="line">        <span class="comment">############################ LeaderRank，删去即为 PageRank ##################################</span></span><br><span class="line">                rank += damping_value</span><br><span class="line">                change += <span class="built_in">abs</span>(leader_rank[node] - rank)  <span class="comment"># 绝对值</span></span><br><span class="line">                leader_rank[node] = rank</span><br><span class="line"></span><br><span class="line">            <span class="comment">#print(f&quot;第&#123;(i + 1)&#125;次迭代，各个节点的 LeaderRank 值：&quot;)</span></span><br><span class="line">            <span class="comment">#print(leader_rank)</span></span><br><span class="line">            <span class="comment">#print()</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> change &lt; self.min_delta:</span><br><span class="line">                flag = <span class="literal">True</span></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;共迭代了<span class="subst">&#123;i+<span class="number">1</span>&#125;</span>次。&quot;</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            </span><br><span class="line">        <span class="comment">############################ LeaderRank，与 PageRank 不同部分 ###############################</span></span><br><span class="line">        <span class="comment"># 节点 g 的 LR 值平均分给其它的N个节点并且删除节点</span></span><br><span class="line">        avg = leader_rank[<span class="string">&#x27;g&#x27;</span>] / graph_size</span><br><span class="line">        leader_rank.pop(<span class="string">&#x27;g&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> leader_rank.keys():</span><br><span class="line">            leader_rank[k] += avg</span><br><span class="line">        <span class="comment">############################ LeaderRank，删去即为 PageRank ##################################</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> flag:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;在最高迭代次数<span class="subst">&#123;self.max_iterations&#125;</span>内，迭代结束！&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;超过了最高迭代次数！&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> leader_rank   </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># demo 中5个节点，8条边</span></span><br><span class="line">    excel_path = <span class="string">&#x27;./demo_data.xlsx&#x27;</span></span><br><span class="line">    all_data = read_excel2data(excel_path)</span><br><span class="line"></span><br><span class="line">    <span class="comment">############################################################################################</span></span><br><span class="line">    <span class="comment">#不加权重</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;【不考虑边的权重】&quot;</span>)</span><br><span class="line">    demo_dg = build_data(all_data)</span><br><span class="line">    <span class="comment"># print(demo_dg2.edges(data=&quot;weight&quot;)) # 查看权重</span></span><br><span class="line">    <span class="comment"># print(demo_dg2.edges) # 不查看权重</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;图矩阵已构建！&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;...&quot;</span>)</span><br><span class="line"></span><br><span class="line">    lr = LRModel(demo_dg)</span><br><span class="line">    leader_ranks2 = lr.leader_rank(mode=<span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    sorted_leader_ranks2 = <span class="built_in">sorted</span>(leader_ranks2.items(), key=<span class="keyword">lambda</span> item: item[<span class="number">1</span>],reverse=<span class="literal">True</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;最终的排序结果：&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> n,v <span class="keyword">in</span> sorted_leader_ranks2:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;n&#125;</span>:<span class="subst">&#123;v&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="comment">############################################################################################</span></span><br><span class="line">    <span class="comment"># 加权重</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;【考虑边的权重】&quot;</span>)</span><br><span class="line">    demo_dg2 = build_data(all_data)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;图矩阵已构建！&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;...&quot;</span>)</span><br><span class="line"></span><br><span class="line">    lr2 = LRModel(demo_dg2)</span><br><span class="line">    leader_ranks2 = lr2.leader_rank(mode=<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    sorted_leader_ranks2 = <span class="built_in">sorted</span>(leader_ranks2.items(), key=<span class="keyword">lambda</span> item: item[<span class="number">1</span>],reverse=<span class="literal">True</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;最终的排序结果：&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> n,v <span class="keyword">in</span> sorted_leader_ranks2:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;n&#125;</span>:<span class="subst">&#123;v&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="comment">############################################################################################</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># output</span></span><br><span class="line">【不考虑边的权重】</span><br><span class="line">图矩阵已构建！</span><br><span class="line">...</span><br><span class="line">共迭代了<span class="number">27</span>次。</span><br><span class="line">在最高迭代次数<span class="number">100</span>内，迭代结束！</span><br><span class="line">最终的排序结果：</span><br><span class="line">E:<span class="number">0.2537605095192026</span></span><br><span class="line">A:<span class="number">0.20759481007355385</span></span><br><span class="line">D:<span class="number">0.18412396715496265</span></span><br><span class="line">B:<span class="number">0.15381976553691573</span></span><br><span class="line">C:<span class="number">0.15381976553691573</span></span><br><span class="line">【考虑边的权重】</span><br><span class="line">图矩阵已构建！</span><br><span class="line">...</span><br><span class="line">共迭代了<span class="number">28</span>次。</span><br><span class="line">在最高迭代次数<span class="number">100</span>内，迭代结束！</span><br><span class="line">最终的排序结果：</span><br><span class="line">E:<span class="number">0.24384387300099586</span></span><br><span class="line">A:<span class="number">0.18288925002569967</span></span><br><span class="line">D:<span class="number">0.17555678233142222</span></span><br><span class="line">B:<span class="number">0.17282762965862306</span></span><br><span class="line">C:<span class="number">0.16650192308383807</span></span><br></pre></td></tr></table></figure>
<hr />
<h2 id="参考">参考</h2>
<ul>
<li>博客
<ul>
<li><a href="https://blog.csdn.net/zhihua_oba/article/details/72912100">PageRank算法</a></li>
<li><a href="https://blog.csdn.net/rubinorth/article/details/52215036?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-5&amp;spm=1001.2101.3001.4242">PageRank算法--从原理到实现</a></li>
<li><a href="https://blog.csdn.net/golden1314521/article/details/41597605">PageRank背后的数学</a></li>
</ul></li>
<li>文献
<ul>
<li><a href="http://ilpubs.stanford.edu:8090/422/1/1999-66.pdf">The PageRank Citation Ranking:Bringing Order to the Web</a></li>
<li><a href="https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0021202">Leaders in Social Networks, the Delicious Case</a></li>
<li><a href="https://core.ac.uk/download/pdf/43658822.pdf">Identifying influential spreaders by weighted LeaderRank</a></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>社区检测</category>
      </categories>
      <tags>
        <tag>社区检测</tag>
      </tags>
  </entry>
  <entry>
    <title>【科研】一些术语建议-总结</title>
    <url>/2021/08/16/%E3%80%90%E7%A7%91%E7%A0%94%E3%80%91%E4%B8%80%E4%BA%9B%E6%9C%AF%E8%AF%AD%E5%BB%BA%E8%AE%AE-%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<blockquote>
<p>总结了一些术语中文（或缩写）翻译建议。</p>
</blockquote>
<span id="more"></span>
<h1 id="术语中文或缩写翻译建议">术语中文（或缩写）翻译建议</h1>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">英</th>
<th style="text-align: center;">中</th>
<th style="text-align: center;">备注</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">pooling</td>
<td style="text-align: center;">汇聚</td>
<td style="text-align: center;">不建议“池化”</td>
</tr>
<tr class="even">
<td style="text-align: center;">dropout</td>
<td style="text-align: center;">暂退</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;">universal approximation theorem</td>
<td style="text-align: center;">通用近似定理</td>
<td style="text-align: center;">不建议“万能近似定理”</td>
</tr>
<tr class="even">
<td style="text-align: center;">mask</td>
<td style="text-align: center;">掩码</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;">robustness</td>
<td style="text-align: center;">稳健性</td>
<td style="text-align: center;">不建议“鲁棒性”</td>
</tr>
<tr class="even">
<td style="text-align: center;">dense vector</td>
<td style="text-align: center;">稠密向量</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;">CRF</td>
<td style="text-align: center;">条件随机场</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;">HMMs</td>
<td style="text-align: center;">隐马尔可夫模型</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;">beam search</td>
<td style="text-align: center;">柱搜索</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;">naive bayes</td>
<td style="text-align: center;">朴素贝叶斯</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;">PLSA</td>
<td style="text-align: center;">概率潜在语义分析模型</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;">MLE</td>
<td style="text-align: center;">最大似然估计</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;">EM</td>
<td style="text-align: center;">期望最大化</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;">MAP</td>
<td style="text-align: center;">最大后验概率</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;">LDA</td>
<td style="text-align: center;">潜在狄利克雷分配</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;">binomial</td>
<td style="text-align: center;">二项</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;">NPMI</td>
<td style="text-align: center;">标准化点互信息</td>
<td style="text-align: center;">normalised pointwise mutual information</td>
</tr>
</tbody>
</table>
<ul>
<li>不建议翻译的专有名词
<ul>
<li>transformer</li>
<li>BERT</li>
<li>GPT</li>
<li>Adam</li>
<li>Boosting</li>
<li>Bagging</li>
</ul></li>
</ul>
<h1 id="参考">参考</h1>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/257900201">机器学习常用术语词汇表——上篇</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/257987132">机器学习常用术语词汇表——下篇</a></li>
</ul>
]]></content>
      <categories>
        <category>科研</category>
      </categories>
      <tags>
        <tag>科研</tag>
        <tag>术语</tag>
      </tags>
  </entry>
  <entry>
    <title>【科研】如何撰写高质量科技论文-清华大学刘洋</title>
    <url>/2021/07/27/%E3%80%90%E7%A7%91%E7%A0%94%E3%80%91%E5%A6%82%E4%BD%95%E6%92%B0%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8F%E7%A7%91%E6%8A%80%E8%AE%BA%E6%96%87-%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6%E5%88%98%E6%B4%8B/</url>
    <content><![CDATA[<blockquote>
<p>如何撰写高质量科技论文（第17版）——2021年06月02日</p>
<p>参考：<a href="https://mp.weixin.qq.com/s/KiKObjQRCAIYl6twSj07rA" class="uri">https://mp.weixin.qq.com/s/KiKObjQRCAIYl6twSj07rA</a></p>
</blockquote>
<span id="more"></span>
<h1 id="论文的全局观念">论文的全局观念</h1>
<h2 id="论文的发表流程">论文的发表流程</h2>
<p><img src="https://user-images.githubusercontent.com/48743005/127084293-d4646e0d-912c-4f3c-acb6-7b1cdd395062.png" /></p>
<h2 id="写论文时什么最重要">写论文时什么最重要？</h2>
<p><img src="https://user-images.githubusercontent.com/48743005/127084354-139e7168-54d9-4990-9217-2d09f0cf30af.png" /></p>
<h2 id="信息逻辑与思想">信息、逻辑与思想</h2>
<p><img src="https://user-images.githubusercontent.com/48743005/127084459-a14d7d32-325a-4a85-9c97-6bd95716b6fd.png" /> <img src="https://user-images.githubusercontent.com/48743005/127084508-07e3cbcf-6d93-489d-839a-582fef02d1ab.png" /> <img src="https://user-images.githubusercontent.com/48743005/127084523-0b3289fb-32e1-4b4a-8893-bc426ba174ec.png" /></p>
<h2 id="阅读与写作">阅读与写作</h2>
<p><img src="https://user-images.githubusercontent.com/48743005/127084567-e5257138-c341-4058-9090-10129dfe741f.png" /></p>
<h2 id="观念转变">观念转变</h2>
<p><img src="https://user-images.githubusercontent.com/48743005/127084621-25dff3e1-ddc7-4beb-a298-3589e55d51b3.png" /></p>
<h2 id="全心全意为读者服务">全心全意为读者服务</h2>
<p><img src="https://user-images.githubusercontent.com/48743005/127084660-34f6c150-bf91-42b3-80dc-91b500a6402e.png" /> <img src="https://user-images.githubusercontent.com/48743005/127084726-5b69b295-fe75-420f-9a19-9778068dfb82.png" /></p>
<h1 id="摘要">摘要</h1>
<p><img src="https://user-images.githubusercontent.com/48743005/127084817-74a7700c-ce99-4548-884b-13bd1ba4a6b4.png" /> <img src="https://user-images.githubusercontent.com/48743005/127084832-1ae01cc4-8c92-43d3-8a3e-69354511b3cd.png" /> <img src="https://user-images.githubusercontent.com/48743005/127084896-4a09f8de-ecb1-4180-b850-50abb7043ff0.png" /></p>
<h1 id="介绍">介绍</h1>
<p><img src="https://user-images.githubusercontent.com/48743005/127085014-946ffc71-56af-401f-a987-0c995ecceba1.png" /> <img src="https://user-images.githubusercontent.com/48743005/127085107-cff041d2-543d-4a9e-a0bc-15220cd3c32e.png" /></p>
<h2 id="常见的逻辑">常见的逻辑</h2>
<p><img src="https://user-images.githubusercontent.com/48743005/127085154-01199b64-e8f1-4fc3-bcc5-ee70f45adea1.png" /> <img src="https://user-images.githubusercontent.com/48743005/127085232-ec7f37cc-672b-4ec9-82a0-ba28fc677a4e.png" /></p>
<h2 id="中心句与支撑句">中心句与支撑句</h2>
<p><img src="https://user-images.githubusercontent.com/48743005/127085301-098c3e93-6574-413c-a8c4-267bdfe868ba.png" /> <img src="https://user-images.githubusercontent.com/48743005/127085394-d1a14ce8-a2a3-4ac4-8ae6-41e40c4903ac.png" /></p>
<h2 id="衔接句">衔接句</h2>
<p><img src="https://user-images.githubusercontent.com/48743005/127085447-0282e41c-dad1-43c8-8fbd-c1d71b80d927.png" /> <img src="https://user-images.githubusercontent.com/48743005/127085659-1d7e7a46-fe59-4308-8c8e-5b3eab073c09.png" /></p>
<h2 id="信息元素的易理解度">信息元素的易理解度</h2>
<p><img src="https://user-images.githubusercontent.com/48743005/127085676-354c42af-a765-490a-b88b-f422a1e3d5ec.png" /> <img src="https://user-images.githubusercontent.com/48743005/127085700-32f9b60a-f25f-4a76-8332-1bf09527b7a4.png" /> <img src="https://user-images.githubusercontent.com/48743005/127085730-adb91b89-c2af-4af4-863f-341616fd239d.png" /> <img src="https://user-images.githubusercontent.com/48743005/127085799-46afd67a-c935-43b7-9406-7b4139d6ea82.png" /></p>
<h2 id="小技巧">小技巧</h2>
<p><img src="https://user-images.githubusercontent.com/48743005/127085872-1cdeeeec-b5fc-408a-803b-70b74add46fa.png" /></p>
<h2 id="信息流的变化">信息流的变化</h2>
<p><img src="https://user-images.githubusercontent.com/48743005/127085917-b9a7a072-9f6b-4618-afcd-5eea1deb7557.png" /></p>
<h2 id="图和表的重要性">图和表的重要性</h2>
<p><img src="https://user-images.githubusercontent.com/48743005/127086057-4de04061-e983-40e3-8f3b-a03c9dafe108.png" /></p>
<h2 id="直接列出自己的贡献">直接列出自己的贡献</h2>
<p><img src="https://user-images.githubusercontent.com/48743005/127086106-6398d3db-5140-430f-9b31-b81f32491c54.png" /></p>
<h2 id="全局的连贯性">全局的连贯性</h2>
<p><img src="https://user-images.githubusercontent.com/48743005/127086137-56a2fe77-dc94-40ed-8b7d-5343bdcee1e9.png" /></p>
<h1 id="方法">方法</h1>
<p><img src="https://user-images.githubusercontent.com/48743005/127086199-0246ea21-dc50-4b1c-8af9-168e92fcaf4b.png" /> <img src="https://user-images.githubusercontent.com/48743005/127086212-2646cfe6-ed72-4a6f-a84e-7a58a15ab0bb.png" /> <img src="https://user-images.githubusercontent.com/48743005/127086241-7c43ee48-521d-4a54-90c1-413a227878df.png" /></p>
<h2 id="running-example-是利器">running example 是利器</h2>
<p><img src="https://user-images.githubusercontent.com/48743005/127086314-c3faaa58-bba5-44ef-87f2-7118827bed7c.png" /></p>
<h2 id="一图胜千言">一图胜千言</h2>
<p><img src="https://user-images.githubusercontent.com/48743005/127086389-791fca81-6e59-4250-be19-38951764144e.png" /></p>
<h2 id="方法描述的逻辑顺序">方法描述的逻辑顺序</h2>
<p><img src="https://user-images.githubusercontent.com/48743005/127086448-d6f0f85a-0a30-42a0-96d8-3bc06120cbcb.png" /> <img src="https://user-images.githubusercontent.com/48743005/127086524-61fc6b84-4854-4e4b-8ec2-ed325e75ccb6.png" /></p>
<h2 id="描述的准确性与形式化能力">描述的准确性与形式化能力</h2>
<p><img src="https://user-images.githubusercontent.com/48743005/127086577-41d5597e-cf1b-415d-9c80-0f7552a86c07.png" /></p>
<h1 id="实验">实验</h1>
<p><img src="https://user-images.githubusercontent.com/48743005/127086681-f7fb8d02-d0b4-4c8f-9789-2950c33b8093.png" /> <img src="https://user-images.githubusercontent.com/48743005/127086702-b9e997f6-a70e-4070-badc-c097c6663f4f.png" /></p>
<h2 id="先辅再主">先辅再主</h2>
<p><img src="https://user-images.githubusercontent.com/48743005/127086860-efd2c14b-954d-46e6-8330-d44d11b5a60b.png" /></p>
<h2 id="如何用表">如何用表</h2>
<p><img src="https://user-images.githubusercontent.com/48743005/127086904-e76d774d-87e8-4256-aa5d-60b8dd76e3ba.png" /> <img src="https://user-images.githubusercontent.com/48743005/127086942-945426cc-93e5-4e78-9be8-72661e93c862.png" /></p>
<h2 id="如何用图">如何用图</h2>
<p><img src="https://user-images.githubusercontent.com/48743005/127087004-4fb2eb7d-4a1a-4aaa-98fa-db4b41feceb8.png" /> <img src="https://user-images.githubusercontent.com/48743005/127087084-36b656b9-92ee-4b8c-8dd0-c456747c71bd.png" /></p>
<h1 id="相关工作">相关工作</h1>
<p><img src="https://user-images.githubusercontent.com/48743005/127087102-f52462df-fb31-432e-8630-47ef3bf546b9.png" /> <img src="https://user-images.githubusercontent.com/48743005/127087130-b6c386c1-88cc-4ee1-a6d5-d629a75576ca.png" /> <img src="https://user-images.githubusercontent.com/48743005/127087184-c638c7c3-25ee-4bcb-9af4-ebc78ae81a9c.png" /></p>
<h1 id="英语写作进阶">英语写作进阶</h1>
<p><img src="https://user-images.githubusercontent.com/48743005/127087218-32b560fe-887c-432c-bb2a-d3bb64ccc871.png" /></p>
<h1 id="必须掌握的工具">必须掌握的工具</h1>
<p><img src="https://user-images.githubusercontent.com/48743005/127087258-65c6be95-ff18-4c8f-8d43-ce8a9d561bec.png" /> <img src="https://user-images.githubusercontent.com/48743005/127087276-54f68bcd-a7ab-4b1d-adb3-65e3dd0f121a.png" /></p>
<h1 id="时间管理和获得反馈">时间管理和获得反馈</h1>
<p><img src="https://user-images.githubusercontent.com/48743005/127087298-39a3317c-0029-4c22-81f8-9af0b8e68509.png" /></p>
<h1 id="平时如何学习写论文">平时如何学习写论文</h1>
<p><img src="https://user-images.githubusercontent.com/48743005/127087405-7ad0bd25-6219-4d51-a5b4-1d57b68b67f4.png" /></p>
<h1 id="论文写作的境界">论文写作的境界</h1>
<p><img src="https://user-images.githubusercontent.com/48743005/127087459-86125d60-4255-4e5c-9447-6fdce061ab76.png" /> <img src="https://user-images.githubusercontent.com/48743005/127087587-6d89a50b-03bb-4b10-bb05-0a9abff4c1ac.png" /></p>
<h1 id="总结">总结</h1>
<p><img src="https://user-images.githubusercontent.com/48743005/127087611-cf104dab-6ca5-48e3-bab5-b2323a1a44f6.png" /></p>
]]></content>
      <categories>
        <category>科研</category>
      </categories>
      <tags>
        <tag>科研</tag>
        <tag>写作</tag>
      </tags>
  </entry>
  <entry>
    <title>【科研】科技论文写作总结</title>
    <url>/2021/07/27/%E3%80%90%E7%A7%91%E7%A0%94%E3%80%91%E7%A7%91%E6%8A%80%E8%AE%BA%E6%96%87%E5%86%99%E4%BD%9C%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<blockquote>
<p>科技论文写作总结，不断更新。</p>
</blockquote>
<span id="more"></span>
<h1 id="科技论文总览">科技论文总览</h1>
<blockquote>
<p>撰写论文是科研工作中十分重要的一个环节，它是对所做工作的一个总结，一定要表达清晰。 摘要（Abstract）、介绍（Introduction）、相关工作（Related Work）、方法（Methods）、实验（Experiments）</p>
</blockquote>
<ul>
<li>信息为<strong>表</strong> - 看到的文章</li>
<li>逻辑为<strong>骨</strong> - 文章的脉络</li>
<li><p>思想为<strong>心</strong> - 新颖的思想</p></li>
<li><p><strong>重要观念的转变</strong>：以作者为核心整理工作 -&gt; <code>以读者为核心阐述工作</code></p></li>
</ul>
<p><img src="https://user-images.githubusercontent.com/48743005/127091861-444714ce-bdf9-4df9-b9f3-9b396d7ef752.png" /></p>
<h1 id="摘要abstruct">摘要（Abstruct）</h1>
<blockquote>
<p>摘要是用几句话来简述文章的整体工作，这一部分的作用相当于文章的“广告”，读者通过摘要大致了解文章内容，并进一步决定是否阅读文章。因此，摘要的写作要求用语简单，浅显易懂。</p>
<p>几句话概括一下你的工作（用于简单，外行要看得懂）。</p>
</blockquote>
<ul>
<li>文章关注的问题</li>
<li>文章的核心工作内容</li>
<li>文章的实现方法</li>
<li>文章达到的效果</li>
</ul>
<blockquote>
<p>一个例子。</p>
</blockquote>
<p><img src="https://user-images.githubusercontent.com/48743005/127591791-5d8bfc98-2e51-4b53-a63c-908a41a5e05a.png" /></p>
<h1 id="介绍introduction">介绍（Introduction）</h1>
<blockquote>
<p>引言是文章的关键部分，是在题目和摘要之后对工作的<strong>进一步介绍</strong>。良好的引言能够清晰描述所做的工作，并充分论证<strong>工作的必要性和重要性</strong>，吸引读者深入阅读后续文章。<strong>严密的逻辑链</strong>有助于形成更好的行文框架，讲座中推荐的逻辑链分为三个层次，包括：</p>
</blockquote>
<ul>
<li>说明问题是什么</li>
<li>当前最好的工作面临什么挑战</li>
<li>我们的方法能够缓解上述挑战</li>
</ul>
<p>在形成整体框架后，引言中各段落的写作也可以应用一些技巧。每个段落的<strong>起始</strong>可以是一个论断性的<strong>中心句</strong>；下文中采用<strong>多个前人工作和具体实验数据作为支撑句</strong>，围绕中心句展开论证；<strong>段尾</strong>可以加上<strong>衔接句</strong>，与下一部分进行连接。</p>
<blockquote>
<p>一个例子。</p>
</blockquote>
<p><img src="https://user-images.githubusercontent.com/48743005/127592175-630dcdb2-4e7f-4b50-95de-62e52014fb60.png" /></p>
<h2 id="中心句与衔接句例子">中心句与衔接句例子</h2>
<ul>
<li><code>We believe that it is important ... On one hand, ... On the other hand, ...</code></li>
</ul>
<h2 id="衔接句例子">衔接句例子</h2>
<ul>
<li><code>Therefore, it is necessary to ...</code></li>
</ul>
<h2 id="新技巧">新技巧</h2>
<ul>
<li>在<strong>论文首页</strong>放置一个<strong>图表</strong>有助于提高文章可读性</li>
<li>直接列出自己的贡献</li>
</ul>
<h1 id="相关工作related-work">相关工作（Related Work）</h1>
<blockquote>
<p>在相关工作部分中，应当向读者（审稿人）展示作者对本领域有<strong>全面深刻的认知</strong>，并通过与前人工作的对比凸显本工作的创新性。</p>
<p><strong>避免遗漏关键文献、对前人工作简单堆砌</strong>，甚至通过批评攻击前人工作来说明本工作的优势。</p>
<p>在相关工作<strong>每一部分的最后</strong>，应当<strong>指出本工作与前人工作的差异和创新之处</strong>。</p>
</blockquote>
<h1 id="方法methods">方法（Methods）</h1>
<blockquote>
<p>方法是论文的核心部分。讲座中不建议直接在方法部分罗列公式和证明，而推荐利用<strong>Running Example</strong>等媒介，<strong>首先</strong>用<strong>通俗的语言</strong>描述研究问题和解决方案，<strong>而后</strong>再给出<strong>形式化</strong>表述。</p>
</blockquote>
<blockquote>
<p>一个例子。</p>
</blockquote>
<p><img src="https://user-images.githubusercontent.com/48743005/127592701-b2d9b7bd-766b-49b5-a1e2-41b549243c68.png" /></p>
<h1 id="实验experiments">实验（Experiments）</h1>
<blockquote>
<p>实验的充分性也在很大程度上决定了文章能否被录用。</p>
<p>实验应当<strong>选取公认的标准数据集</strong>和<strong>当前最优的基线系统</strong>，提高实验的说服力。</p>
<p>在结构上，通常<strong>首先</strong>在<strong>开发集</strong>上进行<strong>辅助实验</strong>，<strong>调节超参数</strong>的影响；而后在<strong>测试集</strong>上给出<strong>主实验结果</strong>，论证方法的<strong>有效性和泛用性</strong>。同时，需要给出<strong>显著性检验结果</strong>来证明提出方法显著超过基线方法。</p>
<p>要做到审稿人想不到的地步。</p>
<p>此外，实验图表的使用也应注意到下面的问题，来提高文章易读性：</p>
</blockquote>
<ul>
<li>通常情况下，我们的方法应放在表格下方，总体性的评估指标应放在表格右侧</li>
<li>曲线图中图例的顺序尽量与曲线顺序相一致</li>
<li>图表说明文字应包含充分的信息，具有自解释性</li>
</ul>
<h1 id="写作技巧总结">写作技巧总结</h1>
<ul>
<li>本质上分享思想，呈现信息。</li>
<li>信息的呈现符合读者的认知惯性。</li>
<li>全心全意为读者服务，降低阅读难度，提高愉悦感。</li>
<li>细节决定成败。</li>
<li>不要本末倒置：创新至上，技法为辅。</li>
</ul>
]]></content>
      <categories>
        <category>科研</category>
      </categories>
      <tags>
        <tag>科研</tag>
        <tag>写作</tag>
      </tags>
  </entry>
  <entry>
    <title>【自然语言处理】DeepLearning.AI-1-w1-Logistic Regression</title>
    <url>/2021/07/08/%E3%80%90%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%91DeepLearning-AI-1-w1-Logistic-Regression/</url>
    <content><![CDATA[<blockquote>
<p>Learn to <strong>extract features</strong> from text into <strong>numerical vectors</strong>, then <strong>build a binary classifier</strong> for tweets using <strong>logistic regression</strong>!</p>
</blockquote>
<span id="more"></span>
<h2 id="数据预处理的一般方式">数据预处理的一般方式</h2>
<ul>
<li>预处理（Preprocessing）
<ul>
<li>消除句柄和URL</li>
<li>分词</li>
<li>去除一些停用词，英文中如（and, is, a, on, etc.）</li>
<li>将单词转变为词干（Stemming），如 dancer, dancing, danced, 变为 'danc'</li>
<li>将英文大写转变为小写</li>
</ul></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># example</span></span><br><span class="line"><span class="keyword">import</span> nltk                                <span class="comment"># Python library for NLP</span></span><br><span class="line"><span class="keyword">import</span> re                                  <span class="comment"># library for regular expression operations</span></span><br><span class="line"><span class="keyword">import</span> string                              <span class="comment"># for string operations</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> nltk.corpus <span class="keyword">import</span> stopwords          <span class="comment"># module for stop words that come with NLTK</span></span><br><span class="line"><span class="keyword">from</span> nltk.stem <span class="keyword">import</span> PorterStemmer        <span class="comment"># module for stemming</span></span><br><span class="line"><span class="keyword">from</span> nltk.tokenize <span class="keyword">import</span> word_tokenize   <span class="comment"># module for tokenizing strings</span></span><br><span class="line"></span><br><span class="line">tweet_text = <span class="string">&#x27;My beautiful sunflowers on a sunny Friday morning off :) #sunflowers #favourites #happy #Friday off… https://t.co/3tfYom0N1i&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">preprocess</span>(<span class="params">text, remove_tag=<span class="literal">True</span>, tokenize=<span class="literal">True</span>, remove_stop_p=<span class="literal">True</span>, steam=<span class="literal">True</span>, lower=<span class="literal">True</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    preprocess of text</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(text)</span><br><span class="line">    <span class="keyword">if</span> remove_tag:</span><br><span class="line">        <span class="comment"># remove old style retweet text &quot;RT&quot;</span></span><br><span class="line">        text = re.sub(<span class="string">r&#x27;^RT[\s]+&#x27;</span>, <span class="string">&#x27;&#x27;</span>, text)</span><br><span class="line">        <span class="comment"># remove hyperlinks</span></span><br><span class="line">        text = re.sub(<span class="string">r&#x27;https?:\/\/.*[\r\n]*&#x27;</span>, <span class="string">&#x27;&#x27;</span>, text)</span><br><span class="line">        <span class="comment"># remove hashtags</span></span><br><span class="line">        <span class="comment"># only removing the hash # sign from the word</span></span><br><span class="line">        text = re.sub(<span class="string">r&#x27;#&#x27;</span>, <span class="string">&#x27;&#x27;</span>, text)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;\033[92m&#x27;</span> + text)</span><br><span class="line">        </span><br><span class="line">    text_list = []</span><br><span class="line">    <span class="keyword">if</span> tokenize:</span><br><span class="line">        nltk.download(<span class="string">&#x27;punkt&#x27;</span>)</span><br><span class="line">        text_list = word_tokenize(text)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;\033[94m&#x27;</span> + <span class="built_in">str</span>(text_list))</span><br><span class="line">        </span><br><span class="line">    text_clean = []</span><br><span class="line">    <span class="keyword">if</span> remove_stop_p:</span><br><span class="line">        stopwords_english = stopwords.words(<span class="string">&#x27;english&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> text_list: <span class="comment"># Go through every word in your tokens list</span></span><br><span class="line">            <span class="keyword">if</span> (word <span class="keyword">not</span> <span class="keyword">in</span> stopwords_english <span class="keyword">and</span>  <span class="comment"># remove stopwords</span></span><br><span class="line">                word <span class="keyword">not</span> <span class="keyword">in</span> string.punctuation):  <span class="comment"># remove punctuation</span></span><br><span class="line">                text_clean.append(word)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;\033[92m&#x27;</span> + <span class="built_in">str</span>(text_clean))</span><br><span class="line">        </span><br><span class="line">    text_stem = [] </span><br><span class="line">    <span class="keyword">if</span> steam:</span><br><span class="line">        <span class="comment"># Instantiate stemming class</span></span><br><span class="line">        stemmer = PorterStemmer() </span><br><span class="line">        <span class="comment"># Create an empty list to store the stems</span></span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> text_clean:</span><br><span class="line">            stem_word = stemmer.stem(word)  <span class="comment"># stemming word</span></span><br><span class="line">            text_stem.append(stem_word)  <span class="comment"># append to the list</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;\033[94m&#x27;</span> + <span class="built_in">str</span>(text_stem))</span><br><span class="line">    </span><br><span class="line">    text_lower = []</span><br><span class="line">    <span class="keyword">if</span> lower:</span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> text_stem:</span><br><span class="line">            text_lower.append(word.lower())</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;\033[92m&#x27;</span> + <span class="built_in">str</span>(text_lower))</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">preprocess(tweet_text)</span><br></pre></td></tr></table></figure>
<p><img src="https://user-images.githubusercontent.com/48743005/124874740-a9e35c80-dffa-11eb-9d18-502ba6d8e0a6.png" /></p>
<h2 id="两种将句子特征提取变为向量的方式">两种将句子特征提取变为向量的方式</h2>
<h3 id="方式一---是否出现">方式一 - 是否出现</h3>
<ul>
<li>将要处理的所有文本的 <strong>词汇量</strong> 记作 <span class="math inline">\(V\)</span>
<ul>
<li>对于每句话，出现的词标记为 1，剩余为 0</li>
<li>那么每句话的维度就为 <span class="math inline">\(|V|\)</span></li>
</ul></li>
<li>问题
<ul>
<li>导致训练，预测的计算时间长</li>
</ul></li>
</ul>
<p><img src="https://user-images.githubusercontent.com/48743005/124869856-64bc2c00-dff4-11eb-8c1f-6d2c1581024f.png" /></p>
<h3 id="方式二---频数">方式二 - 频数</h3>
<ul>
<li>假设一个语料库有四句话，两句正面，两句负面</li>
</ul>
<p><img src="https://user-images.githubusercontent.com/48743005/124870314-13606c80-dff5-11eb-8ba5-a7410e0013d4.png" /></p>
<ul>
<li>计算每个 unique 词在 <strong>正面或负面</strong> 中各自出现的 <strong>频数</strong>，构成一个 <strong>词汇表</strong></li>
</ul>
<p><img src="https://user-images.githubusercontent.com/48743005/124870325-18bdb700-dff5-11eb-80eb-f2814986ed2e.png" /></p>
<ul>
<li>用一个 <strong>3维向量</strong> 表示一句话
<ul>
<li>第一维度是 bias</li>
<li>第二维度是 这句话中出现在 <strong>词汇表</strong> 中的词为 <strong>正</strong> 的 <strong>词频和</strong></li>
<li>第二维度是 这句话中出现在 <strong>词汇表</strong> 中的词为 <strong>负</strong> 的 <strong>词频和</strong></li>
<li>于是下面这句话的向量表示是 <span class="math inline">\((1,8,11)\)</span></li>
</ul></li>
</ul>
<p><img src="https://user-images.githubusercontent.com/48743005/124870340-1f4c2e80-dff5-11eb-87e1-3f639dd7e59e.png" /></p>
<p><img src="https://user-images.githubusercontent.com/48743005/124870357-27a46980-dff5-11eb-9223-35dda628ac6e.png" /></p>
]]></content>
      <categories>
        <category>DeepLearning.AI - Coursera - Lesson 1</category>
      </categories>
      <tags>
        <tag>自然语言处理</tag>
      </tags>
  </entry>
  <entry>
    <title>【自然语言处理】研究入门-实验目录</title>
    <url>/2021/07/16/%E3%80%90%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%91%E7%A0%94%E7%A9%B6%E5%85%A5%E9%97%A8-%E5%AE%9E%E9%AA%8C%E7%9B%AE%E5%BD%95/</url>
    <content><![CDATA[<blockquote>
<p>从零开始如何快速进入 NLP 的研究工作。</p>
<p>任何问题，争取通过搜索、交流、和查阅文献得到解决。</p>
<p>不要以书本为解决方案，基于书本的学习方式在研究生阶段不再适合。</p>
</blockquote>
<span id="more"></span>
<hr />
<ol start="0" type="1">
<li>首先具有较强的编码能力 - 这个需要练的，以 Leetcode 为主。</li>
<li>了解各种文本分类任务，去下载 SST2 或者 SST5 句子分类数据。</li>
<li>手写实现一个基于 n-gram 的最大熵分类器 (c++ &amp; numpy)。 抽取 n-gram 特征，转化成为特征向量，实现模型参数矩阵，分类打分，计算概率，最大熵损失，计算模型参数反向梯度，最大熵优化，测试准确率，调参环节，一条龙体会机器学习。</li>
<li>利用深度学习库（例如pytorch）实现 n-gram 最大熵分类。</li>
<li>1-gram分类，使用预训练词向量进行句子分类，了解pooling，理解深度学习。</li>
<li>实现 CNN，理解 CNN 和 n-gram 的关系。</li>
<li>实现 LSTM，理解 LSTM 和 CNN 的关系。</li>
<li>实现 Self-Attention，理解 pooling 和 SelfAttention 关系。</li>
<li>实现 Transformer，了解 Transformer 的各个组件。</li>
<li>理解 word2vec 以及语言模型，动手实现 word2vec。</li>
<li>学会使用 ELMo。</li>
<li>学会使用 BERT，了解 BERT 分词机制。</li>
<li>查找相关论文，了解自己的分类模型和 SOTA 的区别，撰写文档。</li>
<li>了解 NER 与序列标注，下载 conll03 和 GermEval2014 数据。</li>
<li>实现 BiLSTM-CRF 模型。</li>
<li>实现 BERT-(BiLSTM)-CRF 模型，学会处理异常情况。</li>
<li>了解中文分词，查找相关数据，实现分词模型。</li>
<li>查找相关论文，了解对应数据 SOTA 结果，撰写文档。</li>
<li>了解各种序列标注任务。</li>
<li>附加题：多选一，代码 + 报告。</li>
</ol>
<ul>
<li>多模态蕴含分类任务</li>
<li>多语言序列标注任务</li>
<li>句法结构分析</li>
<li>结构化语义分析</li>
<li>逻辑语义分析</li>
<li>词表示方法，从单语言到多语言</li>
<li>Seq2Seq 模型及其应用</li>
<li>变分模型及其应用</li>
<li>自然语言处理中的生成对抗方法</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>【数据结构与算法】Cpp基础数据结构STL</title>
    <url>/2021/07/17/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%91Cpp%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84STL/</url>
    <content><![CDATA[<blockquote>
<p>在 C++ 里有写好的标准模板库，我们称为 STL 库。</p>
<p>它实现了集合、映射表、栈、队列等数据结构和排序、查找等算法。我们可以很方便地调用标准库来进行各类操作。</p>
</blockquote>
<span id="more"></span>
<hr />
<h1 id="动态数组">动态数组</h1>
<h2 id="引用库">引用库</h2>
<p>有时候想开一个数组，但是却不知道应该开多大长度的数组合适，因为我们需要用到的数组可能会根据情况变动，是个时候就需要我们用到动态数组了。 C++ 中的动态数组写作 vector，它的实现被写在 vector 的头文件中，并在所有头文件之后加上一句 <code>using namespac std</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="构建一个动态数组">构建一个动态数组</h2>
<p>现在我们来构造一个动态数组。 C++ 中直接构造一个vector的语句为:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;T&gt;vec;</span><br></pre></td></tr></table></figure>
<p>这样我们定义了一个名为 vec 的储存 T 类型数据的动态数组。其中 T 是我们要储存的数据类型，可以是 int、float、double 或者其他自定义的数据类型等等。初始的时候 vec 是空的。</p>
<h2 id="插入元素">插入元素</h2>
<p>C++ 中通过 <code>push_back ( )</code> 方法在数组最后面插入一个新的元素。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;  <span class="comment">// []</span></span><br><span class="line">    vec.push_back(<span class="number">1</span>); <span class="comment">// [1]</span></span><br><span class="line">    vec.push_back(<span class="number">2</span>); <span class="comment">// [1, 2]</span></span><br><span class="line">    vec.push_back(<span class="number">3</span>); <span class="comment">// [1, 2, 3]</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="获取长度并且访问元素">获取长度并且访问元素</h2>
<p>C++ 中通过 <code>size ( )</code> 方法获取 vector 的长度，通过 <code>[ ]</code> 操作直接访问 vector 中的元素，这一点和数组是一样的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;  <span class="comment">// []</span></span><br><span class="line">    vec.push_back(<span class="number">1</span>); <span class="comment">// [1]</span></span><br><span class="line">    vec.push_back(<span class="number">2</span>); <span class="comment">// [1, 2]</span></span><br><span class="line">    vec.push_back(<span class="number">3</span>); <span class="comment">// [1, 2, 3]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vec.size(); ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, vec[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="修改元素">修改元素</h2>
<p>C++ 中修改 vector 中某个元素很简单，只需要用 = 给它赋值就好了，比如 <code>vec[1]=3</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;  <span class="comment">// []</span></span><br><span class="line">    vec.push_back(<span class="number">1</span>); <span class="comment">// [1]</span></span><br><span class="line">    vec.push_back(<span class="number">2</span>); <span class="comment">// [1, 2]</span></span><br><span class="line">    vec.push_back(<span class="number">3</span>); <span class="comment">// [1, 2, 3]</span></span><br><span class="line">    vec[<span class="number">1</span>] = <span class="number">3</span>; <span class="comment">// [1, 3, 3]</span></span><br><span class="line">    vec[<span class="number">2</span>] = <span class="number">2</span>; <span class="comment">// [1, 3, 2]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vec.size(); ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, vec[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="清空">清空</h2>
<p>C++需调用 clear( ) 方法就可以清空 vector 。 C++中 vector 的 clear( ) 只是清空 vector ，并不会清空开的内存。用一种方法可以清空 vector 的内存。先定义一个空的 vector x，然后用需要清空的 vector 和 x 交换，因为 x 是局部变量，所以会被系统回收内存（注意：大括号一定不能去掉）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; x;</span><br><span class="line">    v.swap(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="c-vector-方法总结">C++ vector 方法总结</h2>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">方法</th>
<th style="text-align: center;">功能</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">push_back</td>
<td style="text-align: center;">在末尾加入一个元素</td>
</tr>
<tr class="even">
<td style="text-align: center;">pop_back</td>
<td style="text-align: center;">在末尾弹出一个元素</td>
</tr>
<tr class="odd">
<td style="text-align: center;">size</td>
<td style="text-align: center;">获取长度</td>
</tr>
<tr class="even">
<td style="text-align: center;">clear</td>
<td style="text-align: center;">清空</td>
</tr>
</tbody>
</table>
<hr />
<h1 id="集合">集合</h1>
<p>集合是数学中的一个基本概念，通俗地讲，集合是由一些不重复的数据组成的。比如 { 1 , 2 , 3 } 就是一个有1，2，3的集合。C++ 的标准库中的集合支持高效的插入、删除合查询操作，这三个操作的时间复杂度都是 O(lgn)，其中n是当前集合中元素的个数。如果用数组，虽然插入的时间复杂度是 O(1)，但是删除合查询都是 O(n)，此时效率太低。在C++中我们常用的集合是set。</p>
<h2 id="引用库-1">引用库</h2>
<p>C++中的集合实现被写在 <code>set</code> 的头文件中，并在所有头文件之后加上一句 <code>using namespac std</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br></pre></td></tr></table></figure>
<h2 id="构造一个集合">构造一个集合</h2>
<p>现在我们来构造一个集合。 C++ 中直接构造一个 set 的语句为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span>&lt;T&gt; s;</span><br></pre></td></tr></table></figure>
<p>这样我们定义了一个名为s的、储存T类型数据的集合，其中T是集合要储存的数据类型。初始的时候s是空集合。</p>
<h2 id="插入元素-1">插入元素</h2>
<p>C++ 中用 <code>insert( )</code> 方法向集合中插入一个新的元素。注意如果集合中已经存在了某个元素，再次插入不会产生任何效果，集合中是不会出现重复元素的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; country;  <span class="comment">// &#123;&#125;</span></span><br><span class="line">    country.insert(<span class="string">&quot;China&quot;</span>); <span class="comment">// &#123;&quot;China&quot;&#125;</span></span><br><span class="line">    country.insert(<span class="string">&quot;America&quot;</span>); <span class="comment">// &#123;&quot;China&quot;, &quot;America&quot;&#125;</span></span><br><span class="line">    country.insert(<span class="string">&quot;France&quot;</span>); <span class="comment">// &#123;&quot;China&quot;, &quot;America&quot;, &quot;France&quot;&#125;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="删除元素">删除元素</h2>
<p>C++ 中通过 <code>erase( )</code> 方法删除集合中的一个元素，如果集合中不存在这个元素，不进行任何操作。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; country;  <span class="comment">// &#123;&#125;</span></span><br><span class="line">    country.insert(<span class="string">&quot;China&quot;</span>); <span class="comment">// &#123;&quot;China&quot;&#125;</span></span><br><span class="line">    country.insert(<span class="string">&quot;America&quot;</span>); <span class="comment">// &#123;&quot;China&quot;, &quot;America&quot;&#125;</span></span><br><span class="line">    country.insert(<span class="string">&quot;France&quot;</span>); <span class="comment">// &#123;&quot;China&quot;, &quot;America&quot;, &quot;France&quot;&#125;</span></span><br><span class="line">    country.erase(<span class="string">&quot;America&quot;</span>); <span class="comment">// &#123;&quot;China&quot;, &quot;France&quot;&#125;</span></span><br><span class="line">    country.erase(<span class="string">&quot;England&quot;</span>); <span class="comment">// &#123;&quot;China&quot;, &quot;France&quot;&#125;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="查找元素">查找元素</h2>
<p>C++ 中如果你想知道某个元素是否在集合中出现，你可以直接用 <code>count( )</code> 方法。如果集合中存在我们要查找的元素，返回 1 ，否则返回 0 。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; country;  <span class="comment">// &#123;&#125;</span></span><br><span class="line">    country.insert(<span class="string">&quot;China&quot;</span>); <span class="comment">// &#123;&quot;China&quot;&#125;</span></span><br><span class="line">    country.insert(<span class="string">&quot;America&quot;</span>); <span class="comment">// &#123;&quot;China&quot;, &quot;America&quot;&#125;</span></span><br><span class="line">    country.insert(<span class="string">&quot;France&quot;</span>); <span class="comment">// &#123;&quot;China&quot;, &quot;America&quot;, &quot;France&quot;&#125;</span></span><br><span class="line">    <span class="keyword">if</span> (country.count(<span class="string">&quot;China&quot;</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;China belong to country&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="遍历元素">遍历元素</h2>
<p>C++ 通过迭代器可以访问集合中的每个元素，迭代器就好比只想集合中的元素的指针。如果你不了解迭代器，你只需要先记住。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; country;  <span class="comment">// &#123;&#125;</span></span><br><span class="line">    country.insert(<span class="string">&quot;China&quot;</span>); <span class="comment">// &#123;&quot;China&quot;&#125;</span></span><br><span class="line">    country.insert(<span class="string">&quot;America&quot;</span>); <span class="comment">// &#123;&quot;China&quot;, &quot;America&quot;&#125;</span></span><br><span class="line">    country.insert(<span class="string">&quot;France&quot;</span>); <span class="comment">// &#123;&quot;China&quot;, &quot;America&quot;, &quot;France&quot;&#125;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt;::iterator it = country.begin(); it != country.end(); ++it) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; (*it) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：在C++中遍历 set 是从<code>小到大</code>进行的。 ## 清空</p>
<p>C++ 中只需要调用 <code>clear( )</code> 方法就可以清空 set 。</p>
<h2 id="c-set方法总结">C++ set方法总结</h2>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">方法</th>
<th style="text-align: center;">功能</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">insert</td>
<td style="text-align: center;">插入一个元素</td>
</tr>
<tr class="even">
<td style="text-align: center;">erase</td>
<td style="text-align: center;">删除一个元素</td>
</tr>
<tr class="odd">
<td style="text-align: center;">count</td>
<td style="text-align: center;">判断元素是否在 set 中</td>
</tr>
<tr class="even">
<td style="text-align: center;">size</td>
<td style="text-align: center;">获取元素的个数</td>
</tr>
<tr class="odd">
<td style="text-align: center;">clear</td>
<td style="text-align: center;">清空</td>
</tr>
</tbody>
</table>
<hr />
<h1 id="映射">映射</h1>
<p>映射是指两个集合之间的元素的相互对应关系。通俗地说，就是一个元素对应另外一个元素。比如一个姓名的集合 {&quot;Tom&quot;, &quot;Jone&quot;, &quot;Marry&quot;}，班级集合{1, 2}。姓名与班级之间可以有如下的映射关系： class(&quot;Tom&quot;) = 1 , class(&quot;Jone&quot;) = 2 , class(&quot;Marry&quot;) = 1 我们称其中的姓名集合为 <strong>关键字集合(key)</strong> , 班级集合为 <strong>值集合(value)</strong> 。 在 C++ 中我们常用的映射是 map。</p>
<h2 id="引用库-2">引用库</h2>
<p>C++ 中的 <code>map</code> 实现被写在 <code>set</code> 的头文件中，并在所有头文件之后加上一句 <code>using namespac std</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br></pre></td></tr></table></figure>
<h2 id="构造一个映射">构造一个映射</h2>
<p>现在我们来构造一个映射。 在C++中，我们构造一个 map 的语句为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;T1,T2&gt; m;</span><br></pre></td></tr></table></figure>
<p>这样我们定义了一个名为 m 的从 T1 类型到 T2 类型的映射。初始的时候 m 是空映射。</p>
<h2 id="插入映射">插入映射</h2>
<p>在 C++ 中通过 insert( ) 方法向集合中插入一个新的映射，参数是一个 pair 类型的结构。这里需要用到另外一个 STL 模板 —— 元组(pair)。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">char</span>&gt;(<span class="number">1</span>,<span class="string">&#x27;a&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>定义了一个整数 1 合字符 a 的 pair。我们向映射中加入了新映射对的时候就是通过加入 pair 来实现的。如果插入的 key 之前已经有了 value，不会用插入的新的 value 替代原来的 value，也就是此次插入是无效的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; dict;  <span class="comment">// &#123;&#125;</span></span><br><span class="line">    dict.insert(<span class="built_in">pair</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;(<span class="string">&quot;Tom&quot;</span>, <span class="number">1</span>)); <span class="comment">// &#123;&quot;Tom&quot;-&gt;1&#125;</span></span><br><span class="line">    dict.insert(<span class="built_in">pair</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;(<span class="string">&quot;Jone&quot;</span>, <span class="number">2</span>)); <span class="comment">// &#123;&quot;Tom&quot;-&gt;1, &quot;Jone&quot;-&gt;2&#125;</span></span><br><span class="line">    dict.insert(<span class="built_in">pair</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;(<span class="string">&quot;Mary&quot;</span>, <span class="number">1</span>)); <span class="comment">// &#123;&quot;Tom&quot;-&gt;1, &quot;Jone&quot;-&gt;2, &quot;Mary&quot;-&gt;1&#125;</span></span><br><span class="line">    dict.insert(<span class="built_in">pair</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;(<span class="string">&quot;Tom&quot;</span>, <span class="number">2</span>)); <span class="comment">// &#123;&quot;Tom&quot;-&gt;1, &quot;Jone&quot;-&gt;2, &quot;Mary&quot;-&gt;1&#125;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="访问映射">访问映射</h2>
<p>在 C++ 中访问映射合数组一样，直接用 [] 就能访问。比如 dict[&quot;Tom&quot;] 就可以获取 &quot;Tom&quot; 的班级了。而这里有一个比较神奇的地方，如果没有对 &quot;Tom&quot; 做过映射的话，此时你访问 dict[&quot;Tom&quot;] ，系统将会自动为 &quot;Tom&quot; 生成一个映射，其 value 为对应类型的默认值。并且我们可以之后再给映射赋予新的值，比如 dict[&quot;Tom&quot;] = 3 ，这样为我们提供了另一种方便的插入手段。当然有些时候，我们不希望系统自动为我们生成映射，这时候我们需要检测 &quot;Tom&quot; 是否已经有映射了，如果已经有映射再继续访问。这时候就需要用 count( ) 函数进行判断。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; dict;  <span class="comment">// &#123;&#125;</span></span><br><span class="line">    dict[<span class="string">&quot;Tom&quot;</span>] = <span class="number">1</span>; <span class="comment">// &#123;&quot;Tom&quot;-&gt;1&#125;</span></span><br><span class="line">    dict[<span class="string">&quot;Jone&quot;</span>] = <span class="number">2</span>; <span class="comment">// &#123;&quot;Tom&quot;-&gt;1, &quot;Jone&quot;-&gt;2&#125;</span></span><br><span class="line">    dict[<span class="string">&quot;Mary&quot;</span>] = <span class="number">1</span>; <span class="comment">// &#123;&quot;Tom&quot;-&gt;1, &quot;Jone&quot;-&gt;2, &quot;Mary&quot;-&gt;1&#125;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Mary is in class %d\n&quot;</span>, dict[<span class="string">&quot;Mary&quot;</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Tom is in class %d\n&quot;</span>, dict[<span class="string">&quot;Tom&quot;</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="查找关键字">查找关键字</h2>
<p>在 C++ 中，如果你想知道某个关键字是否被映射过，你可以直接用 <code>count( )</code> 方法。如果被映射过，返回 1 ，否则返回 0 。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; dict;  <span class="comment">// &#123;&#125;</span></span><br><span class="line">    dict[<span class="string">&quot;Tom&quot;</span>] = <span class="number">1</span>; <span class="comment">// &#123;&quot;Tom&quot;-&gt;1&#125;</span></span><br><span class="line">    dict[<span class="string">&quot;Jone&quot;</span>] = <span class="number">2</span>; <span class="comment">// &#123;&quot;Tom&quot;-&gt;1, &quot;Jone&quot;-&gt;2&#125;</span></span><br><span class="line">    dict[<span class="string">&quot;Mary&quot;</span>] = <span class="number">1</span>; <span class="comment">// &#123;&quot;Tom&quot;-&gt;1, &quot;Jone&quot;-&gt;2, &quot;Mary&quot;-&gt;1&#125;</span></span><br><span class="line">    <span class="keyword">if</span> (dict.count(<span class="string">&quot;Mary&quot;</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Mary is in class %d\n&quot;</span>, dict[<span class="string">&quot;Mary&quot;</span>]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Mary has no class&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="遍历映射">遍历映射</h2>
<p>在 C++ 中，通过迭代器可以访问映射中的每个映射，每个迭代器的 first 值对应 key，second 值对应 value。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; dict;  <span class="comment">// &#123;&#125;</span></span><br><span class="line">    dict[<span class="string">&quot;Tom&quot;</span>] = <span class="number">1</span>; <span class="comment">// &#123;&quot;Tom&quot;-&gt;1&#125;</span></span><br><span class="line">    dict[<span class="string">&quot;Jone&quot;</span>] = <span class="number">2</span>; <span class="comment">// &#123;&quot;Tom&quot;-&gt;1, &quot;Jone&quot;-&gt;2&#125;</span></span><br><span class="line">    dict[<span class="string">&quot;Mary&quot;</span>] = <span class="number">1</span>; <span class="comment">// &#123;&quot;Tom&quot;-&gt;1, &quot;Jone&quot;-&gt;2, &quot;Mary&quot;-&gt;1&#125;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;::iterator it = dict.begin(); it != dict.end(); ++it) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; is in class &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="清空-1">清空</h2>
<p>C++ 中只需要调用 Clear( ) 即可清空 map。</p>
<h2 id="c-中-map-常用方法总结">C++ 中 map 常用方法总结</h2>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">方法</th>
<th style="text-align: center;">功能</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">insert</td>
<td style="text-align: center;">插入一对映射</td>
</tr>
<tr class="even">
<td style="text-align: center;">count</td>
<td style="text-align: center;">查找关键字</td>
</tr>
<tr class="odd">
<td style="text-align: center;">erase</td>
<td style="text-align: center;">删除关键字</td>
</tr>
<tr class="even">
<td style="text-align: center;">size</td>
<td style="text-align: center;">获取映射对个数</td>
</tr>
<tr class="odd">
<td style="text-align: center;">clear</td>
<td style="text-align: center;">清空</td>
</tr>
</tbody>
</table>
<hr />
<h1 id="栈">栈</h1>
<p>栈（stack），又名堆栈，是一种运算受限制的线性表类型的数据结构。其限制是只允许在栈的一段进行插入和删除运算。这一端被称为栈顶，相对地，把另一端称为栈底。 可以想像往子弹夹中装子弹的情形，正常情况下只能往子弹夹入口那端装入子弹，这一步就好比向栈中压入元素，称为 push，射击的时候，弹夹会从顶端弹出子弹，这一步就好比从栈顶弹出元素，称为 pop，可以发现，从栈顶弹出的子弹是最后一个压进去的子弹，这也是栈的一个重要性质，先进后出（FILO——first in last out）。另外，用一个 top 指针表示当前栈顶的位置。</p>
<p>下图演示栈的 push 和 pop 的过程。</p>
<p><img src="https://user-images.githubusercontent.com/48743005/126038030-8ec90efe-168a-4edb-920a-95fc86b8dec1.png" /></p>
<h2 id="栈的实现">栈的实现</h2>
<p>关于栈的实现，一种方法是利用数组手动实现，需要固定缓存大小，也就是数组的大小。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">stack</span>[maxsize], top = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>[top++] = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   --top;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">topval</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>[top - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> top &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用 stack 表示存储栈的空间，top 表示当栈顶的指针位置，方法 <code>push( )</code> 压入一个数 x 到栈顶，方法 <code>pop( )</code> 从栈顶弹出一个元素，方法 <code>topval( )</code> 获取栈顶元素。 然而 C++ 中已经有写好的栈的对象，可以直接用。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; S;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    S.push(<span class="number">1</span>);</span><br><span class="line">    S.push(<span class="number">10</span>);</span><br><span class="line">    S.push(<span class="number">7</span>);</span><br><span class="line">    <span class="keyword">while</span> (!S.empty()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; S.top() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        S.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面是 C++ 里的 stack 的用法。push，pop 分别是压栈和出栈，top 是栈顶元素，empty 判断栈是否为空。</p>
<h2 id="栈的两个经典的应用">栈的两个经典的应用</h2>
<ol type="1">
<li>火车车厢入站和出站顺序确定。火车进展的时候车厢编号为从前到后一次 1，2，3，4，5，然后确定一个出站顺序是否合法。这里站台就是一个栈的结构。需要遵循先进后出的顺序。用一个栈模拟就可以得到出站顺序是否合理。</li>
</ol>
<p><img src="https://user-images.githubusercontent.com/48743005/126038101-59960216-727c-47e5-9e7c-17f60f281c7f.png" /></p>
<p>2.用来判断括号是否匹配，经常遇到表达式里面的括号很多的情况，有很多方法来判断，其中最简单的一个方法就是用栈来判断。扫描一遍字符串，当遇到 '(' ，压入栈；当遇到 ')' 的时候，从栈中弹出一个 '(' ，如果栈为空无法弹出元素，说明不合法。最后，如果栈中还有 '(' 也不合法。</p>
<p><a href="http://blog.csdn.net/richard__ting/article/details/78951341">其他应用</a></p>
<hr />
<h1 id="队列">队列</h1>
<p>队列（queue）是一种线性的数据结构，和栈一样是一种运算受限制的线性表。其限制只允许从表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作。一般允许进行插入的一端我们称为队尾，允许删除的一端称为队首。队列的插入操作又叫入队，队列的删除操作又叫出队。 可以把队列想像成购物时排队结账的时候的队伍，先排队的人会先结账，后排队的人会后结账，并且不允许有插队的行为，只能在队伍的末尾进行排队。这就是队列的特点，具有先进先出（FIFO——First in First out）的性质。</p>
<p>队列的结构如图示：</p>
<p><img src="https://user-images.githubusercontent.com/48743005/126038133-ba78494c-1503-42d3-9940-b5cdefc80b9c.png" /></p>
<p>队列的主要操作包括：</p>
<ul>
<li>入队（push）</li>
<li>出队（pop）</li>
<li>判断队列是否为空（empty）</li>
<li>统计队列元素的个数（size）</li>
<li>访问队头元素（front）</li>
<li>访问队尾元素（back）</li>
</ul>
<h2 id="队列的实现与使用">队列的实现与使用</h2>
<p>由于队列和栈都是线性表，所以队列也同样可以用数组模拟来手动实现。但是由于队列的出队和入队在不同的两端，所以我们要引入一个循环队列的概念。</p>
<p>如果单纯地用数组进行模拟，那么当有元素出队的时候，我们有两种方法处理剩余的元素：第一种是保持队首（front）位置不变，其余所有的元素顺序往前移动一位；第二种是让队首（front）向后移动一位，其余每个元素的位置不变，也就是使现在的位置称为新的队首位置。</p>
<p>第一种方法需要移动队列的所有元素，时间效率非常低，第二种只需要移动队头则变得非常简单，但第二种会导致之前队头所在的位置以后不会再被用到，造成空间的浪费。循环队列就解决了这个问题。</p>
<p>在实际使用队列中，为了使队列的空间能重复使用，一旦队列的头（front）或者尾（rear）超出了所分配的队列空间，则让它指向队列的起始位置，从 MaxSize -1 增加 1 变成 0 。</p>
<p>例如，下图是一个循环队列，由于之前的出队操作，导致 front 已经移动倒了 4 的位置，如果继续添加元素那么 rear 就会移动到 0 的位置。</p>
<p><img src="https://user-images.githubusercontent.com/48743005/126038154-90a49466-9780-4249-9467-85ac6400e783.png" /></p>
<p>当元素装满整个队列之后就会造成溢出，所以如果要动手实现队列的话，最好提前预估队列的最大容量。 手动实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxsize 10000</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">queue</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> q[maxsize];</span><br><span class="line">    <span class="keyword">int</span> front, rear, count;</span><br><span class="line">    <span class="built_in">queue</span>() &#123;</span><br><span class="line">        front = <span class="number">0</span>;</span><br><span class="line">        rear = <span class="number">0</span>;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span> (count == maxsize) &#123;</span><br><span class="line">            <span class="comment">// 溢出</span></span><br><span class="line">        &#125;</span><br><span class="line">        q[rear] = x;</span><br><span class="line">        rear = (rear + <span class="number">1</span>) % maxsize;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        count--;</span><br><span class="line">        front = (front + <span class="number">1</span>) % maxsize;</span><br><span class="line">        <span class="keyword">return</span> q[front];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">front_val</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> q[front];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="基本操作">基本操作</h2>
<table>
<thead>
<tr class="header">
<th>操作</th>
<th>C++</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>入队</td>
<td>push</td>
</tr>
<tr class="even">
<td>出队</td>
<td>pop</td>
</tr>
<tr class="odd">
<td>访问队首元素</td>
<td>front</td>
</tr>
<tr class="even">
<td>大小</td>
<td>size</td>
</tr>
<tr class="odd">
<td>是否为空</td>
<td>empty</td>
</tr>
</tbody>
</table>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q; <span class="comment">// 声明一个装 int 类型数据的队列</span></span><br><span class="line">    q.push(<span class="number">1</span>); <span class="comment">// 入队</span></span><br><span class="line">    q.push(<span class="number">2</span>);</span><br><span class="line">    q.push(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; q.size() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 输出队列元素个数</span></span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123; <span class="comment">// 判断队列是否为空</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; q.front() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 访问队首元素</span></span><br><span class="line">        q.pop(); <span class="comment">// 出队</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="优先队列">优先队列</h1>
<p>原因：一些问题不能按照传统模式先进先出，要优先访问级别高的元素，这时，就产生了对优先队列的思考。 在队列中，元素从队尾进入，从队首删除。相比队列，优先队列里的元素增加了优先级的属性，优先级高的元素先被删除。</p>
<p>C++代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span>&gt; q; <span class="comment">// 声明一个装 int 类型数据的优先队列</span></span><br><span class="line">    q.push(<span class="number">1</span>); <span class="comment">// 入队</span></span><br><span class="line">    q.push(<span class="number">2</span>);</span><br><span class="line">    q.push(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123; <span class="comment">// 判断队列是否为空</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; q.top() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 访问队列首元素</span></span><br><span class="line">        q.pop(); <span class="comment">// 出队</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出为</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="例题讲解">例题讲解</h2>
<p>给出两个包含 n 个整数的数组 A，B。在 A、B 中任意取出一个数并将这两个数相加，可以得到 <span class="math inline">\(n^2\)</span> 个和。求这些和中最小的 n 个。</p>
<p>解析：如果按照朴素算法，依次在 A 和 B 中分别取出一个数，然后生成和值，最后排序以后取前面的 n 个和。这样的时间复杂度是 <span class="math inline">\(n^2logn\)</span>。效率不高。 我们可以借助优先队列来解决这题。首先把 A，B按照从小到大的顺序排序。观察下面这个表格。</p>
<p><img src="https://user-images.githubusercontent.com/48743005/126038216-ce10e7ca-ca4d-4b22-a04c-ab7a55b098d4.png" /></p>
<p>我们用一个结构 (sum,a,b) 来表示一个和值。</p>
<p>我们建立一个优先队列q，队列中 sum 越小优先级越高。初始的时候，将（A[i]+B[1], i, 1）入队。然后在队中取出一个结构（sum, a, b），然后把结构（A[a]+B[b+1], a, b+1）重新入队。这样重复 n 次。取出的一次就是最小的 n 个和。任何时候，优先队列中最多只会有 n 个元素。所以这样的复杂度是 nlgn。整个过程中，我们发现同一个表中，下标 a 其实不会变，所以可以不用记录下标 a，这样结构就可以简化成（sum，b）。</p>
<p>推广： 上面是只有两个数组的。如果是 n 个数组，每个数组取出一个元素，也可以用这个方法，每次合并两个，合并 n 次就可以了。</p>
<h2 id="优先队列的优先级重载">优先队列的优先级重载</h2>
<p>优先队列，可以存放数值，也可以存放其他数据类型（包括自定义数据类型）。该容器支持查询优先级最高的这一操作，而优先级的高低是可以自行定义的。</p>
<p>在C++中我们可以通过重载小于运算符 <code>bool operator &lt;</code> 来实现。</p>
<p>比如整数，程序默认是数值较大的元素优先级较高，我们一可以定义数值较小的元素优先级较高。又比如下面的例子，定义距离值较小的 node 优先值较高。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> dist, loc;</span><br><span class="line">    node() &#123; &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp; a) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dist &gt; a.dist;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">priority_queue</span> &lt;node&gt; Q;</span><br></pre></td></tr></table></figure>
<p>上述代码起到优先级重载的作用，我们仍然可以进行 top，pop 等操作。</p>
<hr />
<h1 id="并查集">并查集</h1>
<p>并查集是一种树型的数据结构，用于处理一些不相加集合的合并和查询问题。在使用中常常以森林来表示。</p>
<p>并查集也是用来维护集合的，和 set 不同之处在于，并查集能很方便地同时维护很多集合。如果用 set 来维护会非常麻烦。并查集的<strong>核心思想是记录每个结点的父亲结点是哪个结点。</strong></p>
<p>1)<strong>初始化</strong>：初始化的时候每个结点各自为一个集合，father[i]表示结点 i 的父亲结点，如果father[i] = i，我们认为这个结点是当前集合的根节点。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        father[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2)<strong>查找</strong>：查找结点所在集合的根节点，结点 x 的根节点必然也是其父亲结点的根节点。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int get(int x) &#123;</span><br><span class="line">    if (father[x] == x) &#123; // x 结点就是根结点</span><br><span class="line">        return x; </span><br><span class="line">    &#125;</span><br><span class="line">    return get(father[x]); // 返回父结点的根结点</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3)<strong>合并</strong>：将两个元素所在的集合合并在一起，通常来说，合并之前先判断两个元素是否属于同一集合。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void merge(int x, int y) &#123;</span><br><span class="line">    x = get(x);</span><br><span class="line">    y = get(y);</span><br><span class="line">    if (x != y) &#123; // 不在同一个集合</span><br><span class="line">        father[y] = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="路径压缩">路径压缩</h2>
<p>前面的并查集的复杂度实际上在有些极端情况会很慢。比如树的结构正好是一条链，那么最坏情况下，每次查询的复杂度达到了O(n)。这并不是我们期望的结果。</p>
<p><strong>路径压缩</strong>的思想是，我们只关心每个结点的父结点，而并不太关心树的真正的结构。这样我们在一次查询的时候，可以把查询路径上的所有结点的 father[i] 都赋值成为根节点。只需要做出如下改变：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int get(int x) &#123;</span><br><span class="line">    if (father[x] == x) &#123; // x 结点就是根结点</span><br><span class="line">        return x; </span><br><span class="line">    &#125;</span><br><span class="line">    return father[x] = get(father[x]); // 返回父结点的根结点，并令当前结点父结点直接为根结点</span><br><span class="line">    //注意，这里一次性将所有非根结点的结点都通过递归直接与根节点相连，成扁平状。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下图是路径压缩前后的对比。</p>
<p><img src="https://user-images.githubusercontent.com/48743005/126038282-e9ac69fb-dfee-4f12-bbe3-3c262693e36b.png" /></p>
<p>路径压缩在实际应用中效率很高，其依次查询复杂度平摊下来可以认为是一个常数。并且在实际应用中，我们基本都用带路径压缩的并查集。</p>
<h2 id="带权并查集">带权并查集</h2>
<p>所谓<strong>带权并查集</strong>，是指结点存有权值信息的并查集。并查集以森林的形式存在，而结点的权值，大多是记录该结点与祖先关系的信息。比如权值可以记录该结点到根节点的距离。</p>
<p><strong>例题</strong></p>
<p>在排队过程中，初始时，一人一列。一共有如下两种操作。</p>
<ul>
<li>合并：令其中的两个队列 A，B 合并，也就是将队列 A 排在队列 B 的后面。</li>
<li>查询：询问某个人在其所在队列中排在第几位。</li>
</ul>
<p><strong>例题解析</strong></p>
<p>我们不妨设 size[] 为集合中的元素个数，dist[] 为元素到队首的距离，合并时，dist[A.root]需要加上size[B.root] (每个元素到队首的距离应该是到根路径上所有点的 dist[] 求和)，size[B.root]需要加上size[A.root] (每个元素所在集合的元素个数只需查询该集合中根的size[x.root])。</p>
<p>1)<strong>初始化</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)  &#123;</span><br><span class="line">        father[i] = i, dist[i] = <span class="number">0</span>, size[i] = <span class="number">1</span>;<span class="comment">//初始化</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2)<strong>查找</strong>：查找元素所在的集合，即根节点。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(father[x] == x) &#123;</span><br><span class="line">        <span class="keyword">return</span> x;        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//下面1、2步为路径压缩，每个点都指向自己的根结点了。</span></span><br><span class="line">    <span class="comment">//这里一次性将所有非根结点的结点都通过递归直接与根节点相连，成扁平状。</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">int</span> y = father[x];<span class="comment">//1 --得到x的父亲节点</span></span><br><span class="line">    father[x] = get(y);<span class="comment">//2 --将x直接指向根节点get(y)</span></span><br><span class="line">    </span><br><span class="line">    dist[x] += dist[y];  <span class="comment">// (x到根结点的距离) 等于 (x到之前父亲结点距离) 加上 (之前父亲结点到根结点的距离)</span></span><br><span class="line">    <span class="keyword">return</span> father[x];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>路径压缩的时候，不需要考虑 size[]，但 dist[] 需要更新成到整个集合根的距离。</p>
<p>3)<strong>合并</strong></p>
<p>将两个元素所在的集合合并为一个集合。 通常来说，合并之前，应先判断两个元素是否属于同一个集合，这可用上面的“查找”操作实现。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void merge(int a, int b) &#123;</span><br><span class="line">    a = get(a);</span><br><span class="line">    b = get(b);</span><br><span class="line">    if(a != b) &#123;  // 判断两个元素是否属于同一集合</span><br><span class="line">        father[a] = b;</span><br><span class="line">        dist[a] += size[b];//原因是A队伍跑到B队伍后面去了，注意这是针对例题的</span><br><span class="line">        size[b] += size[a];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过小小的改动，我们就可以查询并查集这一森林中，每个元素到祖先的相关信息。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>Cpp</tag>
      </tags>
  </entry>
</search>
